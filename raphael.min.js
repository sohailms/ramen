(function(glob) {
  /** @type {string} */
  var version = "0.4.2";
  /** @type {string} */
  var has = "hasOwnProperty";
  /** @type {RegExp} */
  var core_rnotwhite = /[\.\/]/;
  /** @type {string} */
  var el = "*";
  /**
   * @return {undefined}
   */
  var self = function() {
  };
  /**
   * @param {number} a
   * @param {number} b
   * @return {?}
   */
  var sortOrder = function(a, b) {
    return a - b;
  };
  var value;
  var queuedFn;
  var events = {
    n : {}
  };
  /**
   * @param {string} name
   * @param {Function} scope
   * @return {?}
   */
  var eve = function(name, scope) {
    var i;
    var ln;
    /** @type {string} */
    name = String(name);
    var e = events;
    var fn = queuedFn;
    /** @type {Array.<?>} */
    var args = Array.prototype.slice.call(arguments, 2);
    var listeners = eve.listeners(name);
    /** @type {number} */
    var z = 0;
    var l;
    /** @type {Array} */
    var indexed = [];
    var queue = {};
    /** @type {Array} */
    var result = [];
    var newValue = value;
    /** @type {string} */
    value = name;
    /** @type {number} */
    queuedFn = 0;
    /** @type {number} */
    i = 0;
    ln = listeners.length;
    for (;i < ln;i++) {
      if ("zIndex" in listeners[i]) {
        indexed.push(listeners[i].zIndex);
        if (listeners[i].zIndex < 0) {
          queue[listeners[i].zIndex] = listeners[i];
        }
      }
    }
    indexed.sort(sortOrder);
    for (;indexed[z] < 0;) {
      if (l = queue[indexed[z++]], result.push(l.apply(scope, args)), queuedFn) {
        return queuedFn = fn, result;
      }
    }
    /** @type {number} */
    i = 0;
    for (;i < ln;i++) {
      if (l = listeners[i], "zIndex" in l) {
        if (l.zIndex == indexed[z]) {
          if (result.push(l.apply(scope, args)), queuedFn) {
            break;
          }
          do {
            if (z++, l = queue[indexed[z]], l && result.push(l.apply(scope, args)), queuedFn) {
              break;
            }
          } while (l);
        } else {
          queue[l.zIndex] = l;
        }
      } else {
        if (result.push(l.apply(scope, args)), queuedFn) {
          break;
        }
      }
    }
    return queuedFn = fn, value = newValue, result.length ? result : null;
  };
  eve._events = events;
  /**
   * @param {string} value
   * @return {?}
   */
  eve.listeners = function(value) {
    var a = value.split(core_rnotwhite);
    var n = events;
    var vvar;
    var map;
    var objUid;
    var i;
    var ln;
    var assigns;
    /** @type {Array} */
    var configList = [n];
    /** @type {Array} */
    var ret = [];
    /** @type {number} */
    var ai = 0;
    var al = a.length;
    for (;ai < al;ai++) {
      /** @type {Array} */
      assigns = [];
      /** @type {number} */
      i = 0;
      /** @type {number} */
      ln = configList.length;
      for (;i < ln;i++) {
        n = configList[i].n;
        /** @type {Array} */
        map = [n[a[ai]], n[el]];
        /** @type {number} */
        objUid = 2;
        for (;objUid--;) {
          vvar = map[objUid];
          if (vvar) {
            assigns.push(vvar);
            /** @type {Array} */
            ret = ret.concat(vvar.f || []);
          }
        }
      }
      /** @type {Array} */
      configList = assigns;
    }
    return ret;
  };
  /**
   * @param {string} value
   * @param {Function} target
   * @return {?}
   */
  eve.on = function(value, target) {
    var names;
    var e;
    var i;
    var l;
    if (value = String(value), typeof target != "function") {
      return function() {
      };
    }
    /** @type {Array.<string>} */
    names = value.split(core_rnotwhite);
    e = events;
    /** @type {number} */
    i = 0;
    /** @type {number} */
    l = names.length;
    for (;i < l;i++) {
      e = e.n;
      e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {
        n : {}
      });
    }
    e.f = e.f || [];
    /** @type {number} */
    i = 0;
    l = e.f.length;
    for (;i < l;i++) {
      if (e.f[i] == target) {
        return self;
      }
    }
    return e.f.push(target), function(zIndex) {
      if (+zIndex == +zIndex) {
        /** @type {number} */
        target.zIndex = +zIndex;
      }
    };
  };
  /**
   * @param {?} err
   * @return {?}
   */
  eve.f = function(err) {
    /** @type {Array.<?>} */
    var args = [].slice.call(arguments, 1);
    return function() {
      eve.apply(null, [err, null].concat(args).concat([].slice.call(arguments, 0)));
    };
  };
  /**
   * @return {undefined}
   */
  eve.stop = function() {
    /** @type {number} */
    queuedFn = 1;
  };
  /**
   * @param {string} asNumber
   * @return {?}
   */
  eve.nt = function(asNumber) {
    return asNumber ? (new RegExp("(?:\\.|\\/|^)" + asNumber + "(?:\\.|\\/|$)")).test(value) : value;
  };
  /**
   * @return {?}
   */
  eve.nts = function() {
    return value.split(core_rnotwhite);
  };
  /** @type {function (string, Function): undefined} */
  eve.off = eve.unbind = function(value, listener) {
    var codeSegments;
    var e;
    var key;
    var splice;
    var i;
    var valsLength;
    var j;
    var subLn;
    var cur;
    var listeners;
    if (!value) {
      eve._events = events = {
        n : {}
      };
      return;
    }
    codeSegments = value.split(core_rnotwhite);
    /** @type {Array} */
    cur = [events];
    /** @type {number} */
    i = 0;
    valsLength = codeSegments.length;
    for (;i < valsLength;i++) {
      /** @type {number} */
      j = 0;
      for (;j < cur.length;j += splice.length - 2) {
        if (splice = [j, 1], e = cur[j].n, codeSegments[i] != el) {
          if (e[codeSegments[i]]) {
            splice.push(e[codeSegments[i]]);
          }
        } else {
          for (key in e) {
            if (e[has](key)) {
              splice.push(e[key]);
            }
          }
        }
        cur.splice.apply(cur, splice);
      }
    }
    /** @type {number} */
    i = 0;
    /** @type {number} */
    valsLength = cur.length;
    for (;i < valsLength;i++) {
      e = cur[i];
      for (;e.n;) {
        if (listener) {
          if (e.f) {
            /** @type {number} */
            j = 0;
            subLn = e.f.length;
            for (;j < subLn;j++) {
              if (e.f[j] == listener) {
                e.f.splice(j, 1);
                break;
              }
            }
            if (!e.f.length) {
              delete e.f;
            }
          }
          for (key in e.n) {
            if (e.n[has](key) && e.n[key].f) {
              listeners = e.n[key].f;
              /** @type {number} */
              j = 0;
              subLn = listeners.length;
              for (;j < subLn;j++) {
                if (listeners[j] == listener) {
                  listeners.splice(j, 1);
                  break;
                }
              }
              if (!listeners.length) {
                delete e.n[key].f;
              }
            }
          }
        } else {
          delete e.f;
          for (key in e.n) {
            if (e.n[has](key)) {
              if (e.n[key].f) {
                delete e.n[key].f;
              }
            }
          }
        }
        e = e.n;
      }
    }
  };
  /**
   * @param {string} name
   * @param {Function} matcherFunction
   * @return {?}
   */
  eve.once = function(name, matcherFunction) {
    /**
     * @return {?}
     */
    var h = function() {
      return eve.unbind(name, h), matcherFunction.apply(this, arguments);
    };
    return eve.on(name, h);
  };
  /** @type {string} */
  eve.version = version;
  /**
   * @return {string}
   */
  eve.toString = function() {
    return "You are running Eve " + version;
  };
  if (typeof module != "undefined" && module.exports) {
    /** @type {function (string, Function): ?} */
    module.exports = eve;
  } else {
    if (typeof define != "undefined") {
      define("eve", [], function() {
        return eve;
      });
    } else {
      /** @type {function (string, Function): ?} */
      glob.eve = eve;
    }
  }
})(window || this), function(results, cb) {
  if (typeof define == "function" && define.amd) {
    define(["eve"], function(srcFiles) {
      return cb(results, srcFiles);
    });
  } else {
    cb(results, results.eve);
  }
}(this, function($window, $) {
  /**
   * @param {?} name
   * @return {?}
   */
  function R(name) {
    var a;
    var join;
    return R.is(name, "function") ? set ? name() : $.on("raphael.DOMload", name) : R.is(name, selector) ? R._engine.create[apply](R, name.splice(0, 3 + R.is(name[0], nu))).add(name) : (a = Array.prototype.slice.call(arguments, 0), R.is(a[a.length - 1], "function") ? (join = a.pop(), set ? join.call(R._engine.create[apply](R, a)) : $.on("raphael.DOMload", function() {
      join.call(R._engine.create[apply](R, a));
    })) : R._engine.create[apply](R, arguments));
  }
  /**
   * @param {Object} obj
   * @return {?}
   */
  function merge(obj) {
    var result;
    var key;
    if (typeof obj == "function" || Object(obj) !== obj) {
      return obj;
    }
    result = new obj.constructor;
    for (key in obj) {
      if (obj[has](key)) {
        result[key] = merge(obj[key]);
      }
    }
    return result;
  }
  /**
   * @param {Array} array
   * @param {string} item
   * @return {?}
   */
  function repush(array, item) {
    /** @type {number} */
    var i = 0;
    var array_length = array.length;
    for (;i < array_length;i++) {
      if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
      }
    }
  }
  /**
   * @param {Function} f
   * @param {Function} scope
   * @param {Function} postprocessor
   * @return {?}
   */
  function cacher(f, scope, postprocessor) {
    /**
     * @return {?}
     */
    function newf() {
      /** @type {Array.<?>} */
      var arg = Array.prototype.slice.call(arguments, 0);
      /** @type {string} */
      var args = arg.join("\u2400");
      var cache = newf.cache = newf.cache || {};
      var stack = newf.count = newf.count || [];
      return cache[has](args) ? (repush(stack, args), postprocessor ? postprocessor(cache[args]) : cache[args]) : (stack.length >= 1E3 && delete cache[stack.shift()], stack.push(args), cache[args] = f[apply](scope, arg), postprocessor ? postprocessor(cache[args]) : cache[args]);
    }
    return newf;
  }
  /**
   * @return {?}
   */
  function toStringBench() {
    return this.hex;
  }
  /**
   * @param {Array} path
   * @param {?} obj
   * @return {?}
   */
  function getter(path, obj) {
    var lookup;
    /** @type {Array} */
    var groupMarkers = [];
    /** @type {number} */
    var i = 0;
    var len = path.length;
    for (;len - 2 * !obj > i;i += 2) {
      /** @type {Array} */
      lookup = [{
        x : +path[i - 2],
        y : +path[i - 1]
      }, {
        x : +path[i],
        y : +path[i + 1]
      }, {
        x : +path[i + 2],
        y : +path[i + 3]
      }, {
        x : +path[i + 4],
        y : +path[i + 5]
      }];
      if (obj) {
        if (i) {
          if (len - 4 == i) {
            lookup[3] = {
              x : +path[0],
              y : +path[1]
            };
          } else {
            if (len - 2 == i) {
              lookup[2] = {
                x : +path[0],
                y : +path[1]
              };
              lookup[3] = {
                x : +path[2],
                y : +path[3]
              };
            }
          }
        } else {
          lookup[0] = {
            x : +path[len - 2],
            y : +path[len - 1]
          };
        }
      } else {
        if (len - 4 == i) {
          lookup[3] = lookup[2];
        } else {
          if (!i) {
            lookup[0] = {
              x : +path[i],
              y : +path[i + 1]
            };
          }
        }
      }
      groupMarkers.push(["C", (-lookup[0].x + 6 * lookup[1].x + lookup[2].x) / 6, (-lookup[0].y + 6 * lookup[1].y + lookup[2].y) / 6, (lookup[1].x + 6 * lookup[2].x - lookup[3].x) / 6, (lookup[1].y + 6 * lookup[2].y - lookup[3].y) / 6, lookup[2].x, lookup[2].y]);
    }
    return groupMarkers;
  }
  /**
   * @param {number} d
   * @param {number} a
   * @param {number} b
   * @param {number} keepData
   * @param {number} var_args
   * @return {?}
   */
  function add(d, a, b, keepData, var_args) {
    /** @type {number} */
    var base = -3 * a + 9 * b - 9 * keepData + 3 * var_args;
    /** @type {number} */
    var v0 = d * base + 6 * a - 12 * b + 6 * keepData;
    return d * v0 - 3 * a + 3 * b;
  }
  /**
   * @param {number} event
   * @param {number} y
   * @param {number} callback
   * @param {number} t
   * @param {number} key
   * @param {number} name
   * @param {number} doc
   * @param {number} arg2
   * @param {number} s
   * @return {?}
   */
  function fn(event, y, callback, t, key, name, doc, arg2, s) {
    var i;
    if (s == null) {
      /** @type {number} */
      s = 1;
    }
    s = s > 1 ? 1 : s < 0 ? 0 : s;
    /** @type {number} */
    var n = s / 2;
    /** @type {Array} */
    var data = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
    /** @type {Array} */
    var prevSources = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    /** @type {number} */
    var spacing = 0;
    /** @type {number} */
    i = 0;
    for (;i < 12;i++) {
      /** @type {number} */
      var m = n * data[i] + n;
      var z0 = add(m, event, callback, key, doc);
      var z1 = add(m, y, t, name, arg2);
      /** @type {number} */
      var sum = z0 * z0 + z1 * z1;
      spacing += prevSources[i] * math.sqrt(sum);
    }
    return n * spacing;
  }
  /**
   * @param {number} context
   * @param {number} c
   * @param {number} callback
   * @param {number} type
   * @param {number} next
   * @param {number} arg
   * @param {number} body
   * @param {number} arg2
   * @param {number} value
   * @return {?}
   */
  function handler(context, c, callback, type, next, arg, body, arg2, value) {
    if (!(value < 0) && !(fn(context, c, callback, type, next, arg, body, arg2) < value)) {
      /** @type {number} */
      var p = 1;
      /** @type {number} */
      var s = p / 2;
      /** @type {number} */
      var d = p - s;
      var res = fn(context, c, callback, type, next, arg, body, arg2, d);
      for (;abs(res - value) > 0.01;) {
        s /= 2;
        d += (res < value ? 1 : -1) * s;
        res = fn(context, c, callback, type, next, arg, body, arg2, d);
      }
      return d;
    }
  }
  /**
   * @param {?} x
   * @param {?} y
   * @param {?} x0
   * @param {?} y2
   * @param {?} t1
   * @param {?} x1
   * @param {?} t2
   * @param {?} x2
   * @return {?}
   */
  function getPoint(x, y, x0, y2, t1, x1, t2, x2) {
    if (!(max(x, x0) < min(t1, t2)) && (!(min(x, x0) > max(t1, t2)) && (!(max(y, y2) < min(x1, x2)) && !(min(y, y2) > max(x1, x2))))) {
      /** @type {number} */
      var length = (x * y2 - y * x0) * (t1 - t2) - (x - x0) * (t1 * x2 - x1 * t2);
      /** @type {number} */
      var deltaTime = (x * y2 - y * x0) * (x1 - x2) - (y - y2) * (t1 * x2 - x1 * t2);
      /** @type {number} */
      var duration = (x - x0) * (x1 - x2) - (y - y2) * (t1 - t2);
      if (duration) {
        /** @type {number} */
        var distance = length / duration;
        /** @type {number} */
        var theta = deltaTime / duration;
        /** @type {number} */
        var h = +distance.toFixed(2);
        /** @type {number} */
        var c = +theta.toFixed(2);
        if (!(h < +min(x, x0).toFixed(2)) && (!(h > +max(x, x0).toFixed(2)) && (!(h < +min(t1, t2).toFixed(2)) && (!(h > +max(t1, t2).toFixed(2)) && (!(c < +min(y, y2).toFixed(2)) && (!(c > +max(y, y2).toFixed(2)) && (!(c < +min(x1, x2).toFixed(2)) && !(c > +max(x1, x2).toFixed(2))))))))) {
          return{
            x : distance,
            y : theta
          };
        }
      }
    }
  }
  /**
   * @param {?} array
   * @param {?} name
   * @param {boolean} deepDataAndEvents
   * @return {?}
   */
  function init(array, name, deepDataAndEvents) {
    var t = R.bezierBBox(array);
    var oldconfig = R.bezierBBox(name);
    var x;
    var val;
    var end;
    var t1;
    var size1;
    if (!R.isBBoxIntersect(t, oldconfig)) {
      return deepDataAndEvents ? 0 : [];
    }
    var actual = fn.apply(0, array);
    var tok = fn.apply(0, name);
    /** @type {number} */
    var y = max(~~(actual / 5), 1);
    /** @type {number} */
    var n = max(~~(tok / 5), 1);
    /** @type {Array} */
    var data = [];
    /** @type {Array} */
    var positions = [];
    var rt = {};
    /** @type {(Array|number)} */
    var result = deepDataAndEvents ? 0 : [];
    /** @type {number} */
    x = 0;
    for (;x < y + 1;x++) {
      val = R.findDotsAtSegment.apply(R, array.concat(x / y));
      data.push({
        x : val.x,
        y : val.y,
        t : x / y
      });
    }
    /** @type {number} */
    x = 0;
    for (;x < n + 1;x++) {
      val = R.findDotsAtSegment.apply(R, name.concat(x / n));
      positions.push({
        x : val.x,
        y : val.y,
        t : x / n
      });
    }
    /** @type {number} */
    x = 0;
    for (;x < y;x++) {
      /** @type {number} */
      end = 0;
      for (;end < n;end++) {
        var b = data[x];
        var a = data[x + 1];
        var pos = positions[end];
        var position = positions[end + 1];
        /** @type {string} */
        var axis = abs(a.x - b.x) < 0.001 ? "y" : "x";
        /** @type {string} */
        var i = abs(position.x - pos.x) < 0.001 ? "y" : "x";
        var point = getPoint(b.x, b.y, a.x, a.y, pos.x, pos.y, position.x, position.y);
        if (point) {
          if (rt[point.x.toFixed(4)] == point.y.toFixed(4)) {
            continue;
          }
          rt[point.x.toFixed(4)] = point.y.toFixed(4);
          t1 = b.t + abs((point[axis] - b[axis]) / (a[axis] - b[axis])) * (a.t - b.t);
          size1 = pos.t + abs((point[i] - pos[i]) / (position[i] - pos[i])) * (position.t - pos.t);
          if (t1 >= 0) {
            if (t1 <= 1.001) {
              if (size1 >= 0) {
                if (size1 <= 1.001) {
                  if (deepDataAndEvents) {
                    result++;
                  } else {
                    result.push({
                      x : point.x,
                      y : point.y,
                      t1 : min(t1, 1),
                      t2 : min(size1, 1)
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
    return result;
  }
  /**
   * @param {Object} name
   * @param {Object} t
   * @param {boolean} deepDataAndEvents
   * @return {?}
   */
  function render(name, t, deepDataAndEvents) {
    var last;
    var c;
    var node;
    var data;
    var next;
    var a;
    var fragment;
    var selector;
    var args;
    var elem;
    var results;
    var _i;
    var _len;
    var pair;
    var i;
    var valsLength;
    var p;
    var result;
    var q;
    var n;
    name = R._path2curve(name);
    t = R._path2curve(t);
    /** @type {(Array|number)} */
    results = deepDataAndEvents ? 0 : [];
    /** @type {number} */
    _i = 0;
    _len = name.length;
    for (;_i < _len;_i++) {
      if (pair = name[_i], pair[0] == "M") {
        last = next = pair[1];
        c = a = pair[2];
      } else {
        if (pair[0] == "C") {
          /** @type {Array} */
          args = [last, c].concat(pair.slice(1));
          last = args[6];
          c = args[7];
        } else {
          /** @type {Array} */
          args = [last, c, last, c, next, a, next, a];
          last = next;
          c = a;
        }
        /** @type {number} */
        i = 0;
        valsLength = t.length;
        for (;i < valsLength;i++) {
          if (p = t[i], p[0] == "M") {
            node = fragment = p[1];
            data = selector = p[2];
          } else {
            if (p[0] == "C" ? (elem = [node, data].concat(p.slice(1)), node = elem[6], data = elem[7]) : (elem = [node, data, node, data, fragment, selector, fragment, selector], node = fragment, data = selector), result = init(args, elem, deepDataAndEvents), deepDataAndEvents) {
              results += result;
            } else {
              /** @type {number} */
              q = 0;
              n = result.length;
              for (;q < n;q++) {
                /** @type {number} */
                result[q].segment1 = _i;
                /** @type {number} */
                result[q].segment2 = i;
                result[q].bez1 = args;
                result[q].bez2 = elem;
              }
              results = results.concat(result);
            }
          }
        }
      }
    }
    return results;
  }
  /**
   * @param {string} a
   * @param {?} b
   * @param {?} c
   * @param {?} d
   * @param {?} e
   * @param {?} f
   * @return {undefined}
   */
  function Matrix(a, b, c, d, e, f) {
    if (a != null) {
      /** @type {number} */
      this.a = +a;
      /** @type {number} */
      this.b = +b;
      /** @type {number} */
      this.c = +c;
      /** @type {number} */
      this.d = +d;
      /** @type {number} */
      this.e = +e;
      /** @type {number} */
      this.f = +f;
    } else {
      /** @type {number} */
      this.a = 1;
      /** @type {number} */
      this.b = 0;
      /** @type {number} */
      this.c = 0;
      /** @type {number} */
      this.d = 1;
      /** @type {number} */
      this.e = 0;
      /** @type {number} */
      this.f = 0;
    }
  }
  /**
   * @return {?}
   */
  function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \u00d7 " + this.height;
  }
  /**
   * @param {number} obj
   * @param {number} var_args
   * @param {number} b
   * @param {number} merge
   * @param {number} a
   * @param {number} object
   * @return {?}
   */
  function extend(obj, var_args, b, merge, a, object) {
    /**
     * @param {number} t
     * @return {?}
     */
    function fn(t) {
      return((ay * t + by) * t + cy) * t;
    }
    /**
     * @param {number} a
     * @param {number} c
     * @return {?}
     */
    function inArray(a, c) {
      var width = max(a, c);
      return((y * width + x) * width + offsetX) * width;
    }
    /**
     * @param {number} i
     * @param {number} obj
     * @return {?}
     */
    function max(i, obj) {
      var a;
      var b;
      var val;
      var det;
      /** @type {number} */
      var t = i;
      /** @type {number} */
      var c = 0;
      for (;c < 8;c++) {
        if (val = fn(t) - i, abs(val) < obj) {
          return t;
        }
        if (det = (3 * ay * t + 2 * by) * t + cy, abs(det) < 1E-6) {
          break;
        }
        /** @type {number} */
        t = t - val / det;
      }
      if (a = 0, b = 1, t = i, t < a) {
        return a;
      }
      if (t > b) {
        return b;
      }
      for (;a < b;) {
        if (val = fn(t), abs(val - i) < obj) {
          return t;
        }
        if (i > val) {
          a = t;
        } else {
          b = t;
        }
        /** @type {number} */
        t = (b - a) / 2 + a;
      }
      return t;
    }
    /** @type {number} */
    var cy = 3 * var_args;
    /** @type {number} */
    var by = 3 * (merge - var_args) - cy;
    /** @type {number} */
    var ay = 1 - cy - by;
    /** @type {number} */
    var offsetX = 3 * b;
    /** @type {number} */
    var x = 3 * (a - b) - offsetX;
    /** @type {number} */
    var y = 1 - offsetX - x;
    return inArray(obj, 1 / (200 * object));
  }
  /**
   * @param {Object} key
   * @param {number} opt_parent
   * @return {undefined}
   */
  function Node(key, opt_parent) {
    /** @type {Array} */
    var results = [];
    var result = {};
    var i;
    if (this.ms = opt_parent, this.times = 1, key) {
      for (i in key) {
        if (key[has](i)) {
          result[toFloat(i)] = key[i];
          results.push(toFloat(i));
        }
      }
      results.sort(selector_sortOrder);
    }
    this.anim = result;
    this.top = results[results.length - 1];
    /** @type {Array} */
    this.percents = results;
  }
  /**
   * @param {Object} self
   * @param {Object} element
   * @param {number} id
   * @param {number} recurring
   * @param {?} $route
   * @param {number} $routeParams
   * @return {?}
   */
  function animation(self, element, id, recurring, $route, $routeParams) {
    var opts;
    var i;
    var l;
    var attr;
    var rgba;
    var properties;
    var codeSegments;
    var j;
    var subLn;
    var ctx;
    var options;
    var a;
    var item;
    var values;
    var keys;
    var easing;
    var cc;
    var lc;
    /** @type {number} */
    id = toFloat(id);
    var attrs;
    var o;
    var pt;
    var nextDisabled;
    var prevDisabled;
    var exp;
    var ms = self.ms;
    var from = {};
    var to = {};
    var diff = {};
    if (recurring) {
      /** @type {number} */
      i = 0;
      /** @type {number} */
      l = data.length;
      for (;i < l;i++) {
        if (opts = data[i], opts.el.id == element.id && opts.anim == self) {
          if (opts.percent != id) {
            data.splice(i, 1);
            /** @type {number} */
            pt = 1;
          } else {
            o = opts;
          }
          element.attr(opts.totalOrigin);
          break;
        }
      }
    } else {
      /** @type {number} */
      recurring = +to;
    }
    /** @type {number} */
    i = 0;
    l = self.percents.length;
    for (;i < l;i++) {
      if (self.percents[i] == id || self.percents[i] > recurring * self.top) {
        id = self.percents[i];
        prevDisabled = self.percents[i - 1] || 0;
        /** @type {number} */
        ms = ms / self.top * (id - prevDisabled);
        nextDisabled = self.percents[i + 1];
        attrs = self.anim[id];
        break;
      } else {
        if (recurring) {
          element.attr(self.anim[self.percents[i]]);
        }
      }
    }
    if (attrs) {
      if (o) {
        /** @type {number} */
        o.initstatus = recurring;
        /** @type {number} */
        o.start = new Date - o.ms * recurring;
      } else {
        for (attr in attrs) {
          if (attrs[has](attr) && (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr))) {
            from[attr] = element.attr(attr);
            if (from[attr] == null) {
              from[attr] = availableAttrs[attr];
            }
            to[attr] = attrs[attr];
            switch(availableAnimAttrs[attr]) {
              case nu:
                /** @type {number} */
                diff[attr] = (to[attr] - from[attr]) / ms;
                break;
              case "colour":
                from[attr] = R.getRGB(from[attr]);
                rgba = R.getRGB(to[attr]);
                diff[attr] = {
                  r : (rgba.r - from[attr].r) / ms,
                  g : (rgba.g - from[attr].g) / ms,
                  b : (rgba.b - from[attr].b) / ms
                };
                break;
              case "path":
                properties = path2curve(from[attr], to[attr]);
                codeSegments = properties[1];
                from[attr] = properties[0];
                /** @type {Array} */
                diff[attr] = [];
                /** @type {number} */
                i = 0;
                l = from[attr].length;
                for (;i < l;i++) {
                  /** @type {Array} */
                  diff[attr][i] = [0];
                  /** @type {number} */
                  j = 1;
                  subLn = from[attr][i].length;
                  for (;j < subLn;j++) {
                    /** @type {number} */
                    diff[attr][i][j] = (codeSegments[i][j] - from[attr][i][j]) / ms;
                  }
                }
                break;
              case "transform":
                if (ctx = element._, options = _update(ctx[attr], to[attr]), options) {
                  from[attr] = options.from;
                  to[attr] = options.to;
                  /** @type {Array} */
                  diff[attr] = [];
                  /** @type {boolean} */
                  diff[attr].real = true;
                  /** @type {number} */
                  i = 0;
                  l = from[attr].length;
                  for (;i < l;i++) {
                    /** @type {Array} */
                    diff[attr][i] = [from[attr][i][0]];
                    /** @type {number} */
                    j = 1;
                    subLn = from[attr][i].length;
                    for (;j < subLn;j++) {
                      /** @type {number} */
                      diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                    }
                  }
                } else {
                  a = element.matrix || new Matrix;
                  item = {
                    _ : {
                      transform : ctx.transform
                    },
                    /**
                     * @return {?}
                     */
                    getBBox : function() {
                      return element.getBBox(1);
                    }
                  };
                  /** @type {Array} */
                  from[attr] = [a.a, a.b, a.c, a.d, a.e, a.f];
                  comp(item, to[attr]);
                  to[attr] = item._.transform;
                  /** @type {Array} */
                  diff[attr] = [(item.matrix.a - a.a) / ms, (item.matrix.b - a.b) / ms, (item.matrix.c - a.c) / ms, (item.matrix.d - a.d) / ms, (item.matrix.e - a.e) / ms, (item.matrix.f - a.f) / ms];
                }
                break;
              case "csv":
                if (values = f(attrs[attr])[split](map), keys = f(from[attr])[split](map), attr == "clip-rect") {
                  from[attr] = keys;
                  /** @type {Array} */
                  diff[attr] = [];
                  i = keys.length;
                  for (;i--;) {
                    /** @type {number} */
                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                  }
                }
                to[attr] = values;
                break;
              default:
                values = [][concat](attrs[attr]);
                keys = [][concat](from[attr]);
                /** @type {Array} */
                diff[attr] = [];
                i = element.paper.customAttributes[attr].length;
                for (;i--;) {
                  /** @type {number} */
                  diff[attr][i] = ((values[i] || 0) - (keys[i] || 0)) / ms;
                }
              ;
            }
          }
        }
        if (easing = attrs.easing, cc = R.easing_formulas[easing], cc || (cc = f(easing).match(delegateEventSplitter), cc && cc.length == 5 ? (lc = cc, cc = function(defs) {
          return extend(defs, +lc[1], +lc[2], +lc[3], +lc[4], ms);
        }) : cc = seal), exp = attrs.start || (self.start || +new Date), opts = {
          anim : self,
          percent : id,
          timestamp : exp,
          start : exp + (self.del || 0),
          status : 0,
          initstatus : recurring || 0,
          stop : false,
          ms : ms,
          easing : cc,
          from : from,
          diff : diff,
          to : to,
          el : element,
          callback : attrs.callback,
          prev : prevDisabled,
          next : nextDisabled,
          repeat : $routeParams || self.times,
          origin : element.attr(),
          totalOrigin : $route
        }, data.push(opts), recurring && (!o && (!pt && (opts.stop = true, opts.start = new Date - ms * recurring, data.length == 1)))) {
          return check();
        }
        if (pt) {
          /** @type {number} */
          opts.start = new Date - opts.ms * recurring;
        }
        if (data.length == 1) {
          each(check);
        }
      }
      $("raphael.anim.start." + element.id, element, self);
    }
  }
  /**
   * @param {?} name
   * @return {undefined}
   */
  function name(name) {
    /** @type {number} */
    var i = 0;
    for (;i < data.length;i++) {
      if (data[i].el.paper == name) {
        data.splice(i--, 1);
      }
    }
  }
  var content;
  var e;
  var ff;
  var hf;
  var require;
  var bt;
  var i;
  var draggable;
  var getOffset;
  var options;
  var Set;
  var setproto;
  var method;
  /** @type {string} */
  R.version = "2.1.2";
  /** @type {Object} */
  R.eve = $;
  var set;
  /** @type {RegExp} */
  var map = /[, ]+/;
  var attr = {
    circle : 1,
    rect : 1,
    path : 1,
    ellipse : 1,
    text : 1,
    image : 1
  };
  /** @type {RegExp} */
  var cx = /\{(\d+)\}/g;
  /** @type {string} */
  var has = "hasOwnProperty";
  var win = {
    doc : document,
    win : $window
  };
  var oldRaphael = {
    was : Object.prototype[has].call(win.win, "Raphael"),
    is : win.win.Raphael
  };
  /**
   * @return {undefined}
   */
  var Type = function() {
    this.ca = this.customAttributes = {};
  };
  var paper;
  /** @type {string} */
  var apply = "apply";
  /** @type {string} */
  var concat = "concat";
  var isTouchDevice = "ontouchstart" in win.win || win.win.DocumentTouch && win.doc instanceof DocumentTouch;
  /** @type {string} */
  var E = "";
  /** @type {string} */
  var S = " ";
  /** @type {function (new:String, *=): string} */
  var f = String;
  /** @type {string} */
  var split = "split";
  var codeSegments = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchcancel"[split](S);
  var events = {
    mousedown : "touchstart",
    mousemove : "touchmove",
    mouseup : "mouseup"
  };
  /** @type {function (this:string): string} */
  var lowerCase = f.prototype.toLowerCase;
  var math = Math;
  /** @type {function (...[*]): number} */
  var max = math.max;
  /** @type {function (...[*]): number} */
  var min = math.min;
  /** @type {function (*): number} */
  var abs = math.abs;
  /** @type {function (*, *): number} */
  var pow = math.pow;
  /** @type {number} */
  var PI = math.PI;
  /** @type {string} */
  var nu = "number";
  /** @type {string} */
  var string = "string";
  /** @type {string} */
  var selector = "array";
  /** @type {function (this:*): string} */
  var ostring = Object.prototype.toString;
  /** @type {RegExp} */
  var ne = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i;
  /** @type {RegExp} */
  var colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
  var obj = {
    NaN : 1,
    Infinity : 1,
    "-Infinity" : 1
  };
  /** @type {RegExp} */
  var delegateEventSplitter = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/;
  /** @type {function (*): number} */
  var round = math.round;
  /** @type {function (*): number} */
  var toFloat = parseFloat;
  /** @type {function (*, (number|undefined)): number} */
  var toInt = parseInt;
  /** @type {function (this:string): string} */
  var callback = f.prototype.toUpperCase;
  var availableAttrs = R._availableAttrs = {
    "class" : "",
    "arrow-end" : "none",
    "arrow-start" : "none",
    blur : 0,
    "clip-rect" : "0 0 1e9 1e9",
    cursor : "default",
    cx : 0,
    cy : 0,
    fill : "#fff",
    "fill-opacity" : 1,
    font : '10px "Arial"',
    "font-family" : '"Arial"',
    "font-size" : "10",
    "font-style" : "normal",
    "font-weight" : 400,
    gradient : 0,
    height : 0,
    href : "http://raphaeljs.com/",
    "letter-spacing" : 0,
    opacity : 1,
    path : "M0,0",
    r : 0,
    rx : 0,
    ry : 0,
    src : "",
    stroke : "#000",
    "stroke-dasharray" : "",
    "stroke-linecap" : "butt",
    "stroke-linejoin" : "butt",
    "stroke-miterlimit" : 0,
    "stroke-opacity" : 1,
    "stroke-width" : 1,
    target : "_blank",
    "text-anchor" : "middle",
    title : "Raphael",
    transform : "",
    width : 0,
    x : 0,
    y : 0
  };
  var availableAnimAttrs = R._availableAnimAttrs = {
    blur : nu,
    "clip-rect" : "csv",
    cx : nu,
    cy : nu,
    fill : "colour",
    "fill-opacity" : nu,
    "font-size" : nu,
    height : nu,
    opacity : nu,
    path : "path",
    r : nu,
    rx : nu,
    ry : nu,
    stroke : "colour",
    "stroke-opacity" : nu,
    "stroke-width" : nu,
    transform : "transform",
    width : nu,
    x : nu,
    y : nu
  };
  /** @type {RegExp} */
  var d0 = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/;
  var hsrg = {
    hs : 1,
    rg : 1
  };
  /** @type {RegExp} */
  var emptyParagraphRegexp = /,?([achlmqrstvxz]),?/gi;
  /** @type {RegExp} */
  var r20 = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
  /** @type {RegExp} */
  var rreturn = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig;
  /** @type {RegExp} */
  var rmsPrefix = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig;
  /** @type {RegExp} */
  var te = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/;
  var args = {};
  /**
   * @param {Object} key
   * @param {Object} index
   * @return {?}
   */
  var key = function(key, index) {
    return key.key - index.key;
  };
  /**
   * @param {?} a
   * @param {?} b
   * @return {?}
   */
  var selector_sortOrder = function(a, b) {
    return toFloat(a) - toFloat(b);
  };
  /**
   * @return {undefined}
   */
  var safari = function() {
  };
  /**
   * @param {number} object
   * @return {?}
   */
  var seal = function(object) {
    return object;
  };
  /** @type {function (number, ?, number, number, number): ?} */
  var fillGrid = R._rectPath = function(v00, v11, w, h, r) {
    return r ? [["M", v00 + r, v11], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]] : [["M", v00, v11], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  };
  /**
   * @param {?} message
   * @param {?} worker
   * @param {number} textAlt
   * @param {number} text
   * @return {?}
   */
  var sendMessage = function(message, worker, textAlt, text) {
    return text == null && (text = textAlt), [["M", message, worker], ["m", 0, -text], ["a", textAlt, text, 0, 1, 1, 0, 2 * text], ["a", textAlt, text, 0, 1, 1, 0, -2 * text], ["z"]];
  };
  var VALUE = R._getPath = {
    /**
     * @param {string} state
     * @return {?}
     */
    path : function(state) {
      return state.attr("path");
    },
    /**
     * @param {Object} self
     * @return {?}
     */
    circle : function(self) {
      var obj = self.attrs;
      return sendMessage(obj.cx, obj.cy, obj.r);
    },
    /**
     * @param {Object} options
     * @return {?}
     */
    ellipse : function(options) {
      var obj = options.attrs;
      return sendMessage(obj.cx, obj.cy, obj.rx, obj.ry);
    },
    /**
     * @param {Object} w
     * @return {?}
     */
    rect : function(w) {
      var lastBook = w.attrs;
      return fillGrid(lastBook.x, lastBook.y, lastBook.width, lastBook.height, lastBook.r);
    },
    /**
     * @param {Object} node
     * @return {?}
     */
    image : function(node) {
      var lastBook = node.attrs;
      return fillGrid(lastBook.x, lastBook.y, lastBook.width, lastBook.height);
    },
    /**
     * @param {string} value
     * @return {?}
     */
    text : function(value) {
      var lastBook = value._getBBox();
      return fillGrid(lastBook.x, lastBook.y, lastBook.width, lastBook.height);
    },
    /**
     * @param {?} mL
     * @return {?}
     */
    set : function(mL) {
      var lastBook = mL._getBBox();
      return fillGrid(lastBook.x, lastBook.y, lastBook.width, lastBook.height);
    }
  };
  /** @type {function (Object, ?): ?} */
  var matrix = R.mapPath = function(xs, s) {
    if (!s) {
      return xs;
    }
    var o;
    var value;
    var _i;
    var i;
    var _len;
    var valsLength;
    var t;
    xs = path2curve(xs);
    /** @type {number} */
    _i = 0;
    _len = xs.length;
    for (;_i < _len;_i++) {
      t = xs[_i];
      /** @type {number} */
      i = 1;
      valsLength = t.length;
      for (;i < valsLength;i += 2) {
        o = s.x(t[i], t[i + 1]);
        value = s.y(t[i], t[i + 1]);
        t[i] = o;
        t[i + 1] = value;
      }
    }
    return xs;
  };
  if (R._g = win, R.type = win.win.SVGAngle || win.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML", R.type == "VML") {
    if (content = win.doc.createElement("div"), content.innerHTML = '<v:shape adj="1"/>', e = content.firstChild, e.style.behavior = "url(#default#VML)", !(e && typeof e.adj == "object")) {
      return R.type = E;
    }
    /** @type {null} */
    content = null;
  }
  /** @type {boolean} */
  R.svg = !(R.vml = R.type == "VML");
  /** @type {function (): undefined} */
  R._Paper = Type;
  R.fn = paper = Type.prototype = R.prototype;
  /** @type {number} */
  R._id = 0;
  /** @type {number} */
  R._oid = 0;
  /**
   * @param {?} o
   * @param {string} type
   * @return {?}
   */
  R.is = function(o, type) {
    return(type = lowerCase.call(type), type == "finite") ? !obj[has](+o) : type == "array" ? o instanceof Array : type == "null" && o === null || (type == typeof o && o !== null || (type == "object" && o === Object(o) || (type == "array" && (Array.isArray && Array.isArray(o)) || ostring.call(o).slice(8, -1).toLowerCase() == type)));
  };
  /**
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {?} y2
   * @param {number} x3
   * @param {?} y3
   * @return {?}
   */
  R.angle = function(x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
      /** @type {number} */
      var x = x1 - x2;
      /** @type {number} */
      var y = y1 - y2;
      return!x && !y ? 0 : (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    }
    return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
  };
  /**
   * @param {number} deg
   * @return {?}
   */
  R.rad = function(deg) {
    return deg % 360 * PI / 180;
  };
  /**
   * @param {number} rad
   * @return {?}
   */
  R.deg = function(rad) {
    return rad * 180 / PI % 360;
  };
  /**
   * @param {number} values
   * @param {number} value
   * @param {number} tolerance
   * @return {?}
   */
  R.snapTo = function(values, value, tolerance) {
    var i;
    var rem;
    if (tolerance = R.is(tolerance, "finite") ? tolerance : 10, R.is(values, selector)) {
      i = values.length;
      for (;i--;) {
        if (abs(values[i] - value) <= tolerance) {
          return values[i];
        }
      }
    } else {
      if (values = +values, rem = value % values, rem < tolerance) {
        return value - rem;
      }
      if (rem > values - tolerance) {
        return value - rem + values;
      }
    }
    return value;
  };
  ff = R.createUUID = function(dir, boundary) {
    return function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(dir, boundary).toUpperCase();
    };
  }(/[xy]/g, function(c) {
    /** @type {number} */
    var r = math.random() * 16 | 0;
    /** @type {number} */
    var v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
  /**
   * @param {Window} path
   * @return {undefined}
   */
  R.setWindow = function(path) {
    $("raphael.setWindow", R, win.win, path);
    /** @type {Window} */
    win.win = path;
    win.doc = win.win.document;
    if (R._engine.initWin) {
      R._engine.initWin(win.win);
    }
  };
  /**
   * @param {string} color
   * @return {?}
   */
  var toHex = function(color) {
    var r20;
    var node;
    var doc;
    var range;
    var element;
    if (R.vml) {
      /** @type {RegExp} */
      r20 = /^\s+|\s+$/g;
      try {
        doc = new ActiveXObject("htmlfile");
        doc.write("<body>");
        doc.close();
        node = doc.body;
      } catch (s) {
        node = createPopup().document.body;
      }
      range = node.createTextRange();
      toHex = cacher(function(buf) {
        try {
          /** @type {string} */
          node.style.color = f(buf).replace(r20, E);
          var value = range.queryCommandValue("ForeColor");
          return value = (value & 255) << 16 | value & 65280 | (value & 16711680) >>> 16, "#" + ("000000" + value.toString(16)).slice(-6);
        } catch (i) {
          return "none";
        }
      });
    } else {
      element = win.doc.createElement("i");
      /** @type {string} */
      element.title = "Rapha\u00ebl Colour Picker";
      /** @type {string} */
      element.style.display = "none";
      win.doc.body.appendChild(element);
      toHex = cacher(function(color) {
        return element.style.color = color, win.doc.defaultView.getComputedStyle(element, E).getPropertyValue("color");
      });
    }
    return toHex(color);
  };
  /**
   * @return {?}
   */
  var hsbtoString = function() {
    return "hsb(" + [this.h, this.s, this.b] + ")";
  };
  /**
   * @return {?}
   */
  var hsltoString = function() {
    return "hsl(" + [this.h, this.s, this.l] + ")";
  };
  /**
   * @return {?}
   */
  var rgbtoString = function() {
    return this.hex;
  };
  /**
   * @param {Object} r
   * @param {number} g
   * @param {number} b
   * @return {?}
   */
  var prepareRGB = function(r, g, b) {
    if (g == null && (R.is(r, "object") && ("r" in r && ("g" in r && ("b" in r && (b = r.b, g = r.g, r = r.r))))), g == null && R.is(r, string)) {
      var clr = R.getRGB(r);
      r = clr.r;
      g = clr.g;
      b = clr.b;
    }
    return(r > 1 || (g > 1 || b > 1)) && (r /= 255, g /= 255, b /= 255), [r, g, b];
  };
  /**
   * @param {number} r
   * @param {number} g
   * @param {number} B
   * @param {string} b
   * @return {?}
   */
  var packageRGB = function(r, g, B, b) {
    r *= 255;
    g *= 255;
    B *= 255;
    var c = {
      r : r,
      g : g,
      b : B,
      hex : R.rgb(r, g, B),
      /** @type {function (): ?} */
      toString : rgbtoString
    };
    return R.is(b, "finite") && (c.opacity = b), c;
  };
  /**
   * @param {Object} clr
   * @return {?}
   */
  R.color = function(clr) {
    var rgb;
    return R.is(clr, "object") && ("h" in clr && ("s" in clr && "b" in clr)) ? (rgb = R.hsb2rgb(clr), clr.r = rgb.r, clr.g = rgb.g, clr.b = rgb.b, clr.hex = rgb.hex) : R.is(clr, "object") && ("h" in clr && ("s" in clr && "l" in clr)) ? (rgb = R.hsl2rgb(clr), clr.r = rgb.r, clr.g = rgb.g, clr.b = rgb.b, clr.hex = rgb.hex) : (R.is(clr, "string") && (clr = R.getRGB(clr)), R.is(clr, "object") && ("r" in clr && ("g" in clr && "b" in clr)) ? (rgb = R.rgb2hsl(clr), clr.h = rgb.h, clr.s = rgb.s, clr.l = 
    rgb.l, rgb = R.rgb2hsb(clr), clr.v = rgb.b) : (clr = {
      hex : "none"
    }, clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1)), clr.toString = rgbtoString, clr;
  };
  /**
   * @param {number} h
   * @param {number} s
   * @param {number} v
   * @param {(number|string)} o
   * @return {?}
   */
  R.hsb2rgb = function(h, s, v, o) {
    if (this.is(h, "object")) {
      if ("h" in h) {
        if ("s" in h) {
          if ("b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
          }
        }
      }
    }
    h *= 360;
    var R;
    var G;
    var B;
    var C;
    var X;
    return h = h % 360 / 60, X = v * s, C = X * (1 - abs(h % 2 - 1)), R = G = B = v - X, h = ~~h, R += [X, C, 0, 0, C, X][h], G += [C, X, X, C, 0, 0][h], B += [0, 0, C, X, X, C][h], packageRGB(R, G, B, o);
  };
  /**
   * @param {number} h
   * @param {number} s
   * @param {number} l
   * @param {string} o
   * @return {?}
   */
  R.hsl2rgb = function(h, s, l, o) {
    if (this.is(h, "object")) {
      if ("h" in h) {
        if ("s" in h) {
          if ("l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
          }
        }
      }
    }
    if (h > 1 || (s > 1 || l > 1)) {
      h /= 360;
      s /= 100;
      l /= 100;
    }
    h *= 360;
    var R;
    var G;
    var B;
    var C;
    var X;
    return h = h % 360 / 60, X = 2 * s * (l < 0.5 ? l : 1 - l), C = X * (1 - abs(h % 2 - 1)), R = G = B = l - X / 2, h = ~~h, R += [X, C, 0, 0, C, X][h], G += [C, X, X, C, 0, 0][h], B += [0, 0, C, X, X, C][h], packageRGB(R, G, B, o);
  };
  /**
   * @param {Object} r
   * @param {Object} g
   * @param {Object} b
   * @return {?}
   */
  R.rgb2hsb = function(r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];
    var H;
    var scale;
    var V;
    var C;
    return V = max(r, g, b), C = V - min(r, g, b), H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4, H = (H + 360) % 6 / 6, scale = C == 0 ? 0 : C / V, {
      h : H,
      s : scale,
      b : V,
      /** @type {function (): ?} */
      toString : hsbtoString
    };
  };
  /**
   * @param {Object} r
   * @param {Object} g
   * @param {Object} b
   * @return {?}
   */
  R.rgb2hsl = function(r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];
    var H;
    var scale;
    var L;
    var M;
    var m;
    var C;
    return M = max(r, g, b), m = min(r, g, b), C = M - m, H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4, H = (H + 360) % 6 / 6, L = (M + m) / 2, scale = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L), {
      h : H,
      s : scale,
      l : L,
      /** @type {function (): ?} */
      toString : hsltoString
    };
  };
  /**
   * @return {?}
   */
  R._path2string = function() {
    return this.join(",").replace(emptyParagraphRegexp, "$1");
  };
  /** @type {function (string, Function): undefined} */
  hf = R._preload = function(blank, next_callback) {
    var img = win.doc.createElement("img");
    /** @type {string} */
    img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
    /**
     * @return {undefined}
     */
    img.onload = function() {
      next_callback.call(this);
      /** @type {null} */
      this.onload = null;
      win.doc.body.removeChild(this);
    };
    /**
     * @return {undefined}
     */
    img.onerror = function() {
      win.doc.body.removeChild(this);
    };
    win.doc.body.appendChild(img);
    /** @type {string} */
    img.src = blank;
  };
  R.getRGB = cacher(function(colour) {
    if (!colour || !!((colour = f(colour)).indexOf("-") + 1)) {
      return{
        r : -1,
        g : -1,
        b : -1,
        hex : "none",
        error : 1,
        /** @type {function (): ?} */
        toString : toStringBench
      };
    }
    if (colour == "none") {
      return{
        r : -1,
        g : -1,
        b : -1,
        hex : "none",
        /** @type {function (): ?} */
        toString : toStringBench
      };
    }
    if (!hsrg[has](colour.toLowerCase().substring(0, 2))) {
      if (!(colour.charAt() == "#")) {
        colour = toHex(colour);
      }
    }
    var red;
    var green;
    var blue;
    var p;
    var t;
    var d;
    var rgb = colour.match(colourRegExp);
    return rgb ? (rgb[2] && (blue = toInt(rgb[2].substring(5), 16), green = toInt(rgb[2].substring(3, 5), 16), red = toInt(rgb[2].substring(1, 3), 16)), rgb[3] && (blue = toInt((t = rgb[3].charAt(3)) + t, 16), green = toInt((t = rgb[3].charAt(2)) + t, 16), red = toInt((t = rgb[3].charAt(1)) + t, 16)), rgb[4] && (d = rgb[4][split](d0), red = toFloat(d[0]), d[0].slice(-1) == "%" && (red *= 2.55), green = toFloat(d[1]), d[1].slice(-1) == "%" && (green *= 2.55), blue = toFloat(d[2]), d[2].slice(-1) == 
    "%" && (blue *= 2.55), rgb[1].toLowerCase().slice(0, 4) == "rgba" && (p = toFloat(d[3])), d[3] && (d[3].slice(-1) == "%" && (p /= 100))), rgb[5]) ? (d = rgb[5][split](d0), red = toFloat(d[0]), d[0].slice(-1) == "%" && (red *= 2.55), green = toFloat(d[1]), d[1].slice(-1) == "%" && (green *= 2.55), blue = toFloat(d[2]), d[2].slice(-1) == "%" && (blue *= 2.55), (d[0].slice(-3) == "deg" || d[0].slice(-1) == "\u00b0") && (red /= 360), rgb[1].toLowerCase().slice(0, 4) == "hsba" && (p = toFloat(d[3])), 
    d[3] && (d[3].slice(-1) == "%" && (p /= 100)), R.hsb2rgb(red, green, blue, p)) : rgb[6] ? (d = rgb[6][split](d0), red = toFloat(d[0]), d[0].slice(-1) == "%" && (red *= 2.55), green = toFloat(d[1]), d[1].slice(-1) == "%" && (green *= 2.55), blue = toFloat(d[2]), d[2].slice(-1) == "%" && (blue *= 2.55), (d[0].slice(-3) == "deg" || d[0].slice(-1) == "\u00b0") && (red /= 360), rgb[1].toLowerCase().slice(0, 4) == "hsla" && (p = toFloat(d[3])), d[3] && (d[3].slice(-1) == "%" && (p /= 100)), R.hsl2rgb(red, 
    green, blue, p)) : (rgb = {
      r : red,
      g : green,
      b : blue,
      /** @type {function (): ?} */
      toString : toStringBench
    }, rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1), R.is(p, "finite") && (rgb.opacity = p), rgb) : {
      r : -1,
      g : -1,
      b : -1,
      hex : "none",
      error : 1,
      /** @type {function (): ?} */
      toString : toStringBench
    };
  }, R);
  R.hsb = cacher(function(h, s, b) {
    return R.hsb2rgb(h, s, b).hex;
  });
  R.hsl = cacher(function(h, s, l) {
    return R.hsl2rgb(h, s, l).hex;
  });
  R.rgb = cacher(function(dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist) {
    return "#" + (16777216 | ignoreMethodDoesntExist | deepDataAndEvents << 8 | dataAndEvents << 16).toString(16).slice(1);
  });
  /**
   * @param {number} value
   * @return {?}
   */
  R.getColor = function(value) {
    var start = this.getColor.start = this.getColor.start || {
      h : 0,
      s : 1,
      b : value || 0.75
    };
    var rgb = this.hsb2rgb(start.h, start.s, start.b);
    return start.h += 0.075, start.h > 1 && (start.h = 0, start.s -= 0.2, start.s <= 0 && (this.getColor.start = {
      h : 0,
      s : 1,
      b : start.b
    })), rgb.hex;
  };
  /**
   * @return {undefined}
   */
  R.getColor.reset = function() {
    delete this.start;
  };
  /**
   * @param {string} name
   * @return {?}
   */
  R.parsePathString = function(name) {
    var opts;
    var paramCounts;
    var data;
    return name ? (opts = require(name), opts.arr) ? equal(opts.arr) : (paramCounts = {
      a : 7,
      c : 6,
      h : 1,
      l : 2,
      m : 2,
      r : 4,
      q : 4,
      s : 4,
      t : 2,
      v : 1,
      z : 0
    }, data = [], R.is(name, selector) && (R.is(name[0], selector) && (data = equal(name))), data.length || f(name).replace(r20, function(dataAndEvents, b, string) {
      /** @type {Array} */
      var params = [];
      var name = b.toLowerCase();
      if (string.replace(rmsPrefix, function(dataAndEvents, b) {
        if (b) {
          params.push(+b);
        }
      }), name == "m" && (params.length > 2 && (data.push([b][concat](params.splice(0, 2))), name = "l", b = b == "m" ? "l" : "L")), name == "r") {
        data.push([b][concat](params));
      } else {
        for (;params.length >= paramCounts[name];) {
          if (data.push([b][concat](params.splice(0, paramCounts[name]))), !paramCounts[name]) {
            break;
          }
        }
      }
    }), data.toString = R._path2string, opts.arr = equal(data), data) : null;
  };
  R.parseTransformString = cacher(function(name) {
    if (!name) {
      return null;
    }
    /** @type {Array} */
    var res = [];
    return R.is(name, selector) && (R.is(name[0], selector) && (res = equal(name))), res.length || f(name).replace(rreturn, function(dataAndEvents, b, string) {
      /** @type {Array} */
      var paths = [];
      /** @type {string} */
      var bp = lowerCase.call(b);
      string.replace(rmsPrefix, function(dataAndEvents, num) {
        if (num) {
          paths.push(+num);
        }
      });
      res.push([b][concat](paths));
    }), res.toString = R._path2string, res;
  });
  /**
   * @param {string} name
   * @return {?}
   */
  require = function(name) {
    var attr = require.ps = require.ps || {};
    return attr[name] ? attr[name].sleep = 100 : attr[name] = {
      sleep : 100
    }, setTimeout(function() {
      var key;
      for (key in attr) {
        if (attr[has](key)) {
          if (key != name) {
            attr[key].sleep--;
            if (!attr[key].sleep) {
              delete attr[key];
            }
          }
        }
      }
    }), attr[name];
  };
  /**
   * @param {number} s
   * @param {number} k
   * @param {number} c
   * @param {number} y
   * @param {number} d
   * @param {number} z
   * @param {number} t
   * @param {number} i
   * @param {number} a
   * @return {?}
   */
  R.findDotsAtSegment = function(s, k, c, y, d, z, t, i, a) {
    /** @type {number} */
    var x = 1 - a;
    /** @type {number} */
    var a00 = pow(x, 3);
    /** @type {number} */
    var n = pow(x, 2);
    /** @type {number} */
    var j = a * a;
    /** @type {number} */
    var ts = j * a;
    /** @type {number} */
    var moveX = a00 * s + n * 3 * a * c + x * 3 * a * a * d + ts * t;
    /** @type {number} */
    var moveY = a00 * k + n * 3 * a * y + x * 3 * a * a * z + ts * i;
    var y2 = s + 2 * a * (c - s) + j * (d - 2 * c + s);
    var g = k + 2 * a * (y - k) + j * (z - 2 * y + k);
    var y1 = c + 2 * a * (d - c) + j * (t - 2 * d + c);
    var b = y + 2 * a * (z - y) + j * (i - 2 * z + y);
    /** @type {number} */
    var zx = x * s + a * c;
    /** @type {number} */
    var centerY = x * k + a * y;
    /** @type {number} */
    var initialMoveX = x * d + a * t;
    /** @type {number} */
    var maxY = x * z + a * i;
    /** @type {number} */
    var alpha = 90 - math.atan2(y2 - y1, g - b) * 180 / PI;
    return(y2 > y1 || g < b) && (alpha += 180), {
      x : moveX,
      y : moveY,
      m : {
        x : y2,
        y : g
      },
      n : {
        x : y1,
        y : b
      },
      start : {
        x : zx,
        y : centerY
      },
      end : {
        x : initialMoveX,
        y : maxY
      },
      alpha : alpha
    };
  };
  /**
   * @param {?} x
   * @param {?} y
   * @param {?} dataAndEvents
   * @param {?} deepDataAndEvents
   * @param {?} ignoreMethodDoesntExist
   * @param {?} textAlt
   * @param {?} keepData
   * @param {?} opt_attributes
   * @return {?}
   */
  R.bezierBBox = function(x, y, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes) {
    if (!R.is(x, "array")) {
      /** @type {Array} */
      x = [x, y, dataAndEvents, deepDataAndEvents, ignoreMethodDoesntExist, textAlt, keepData, opt_attributes];
    }
    var bound = curveDim.apply(null, x);
    return{
      x : bound.min.x,
      y : bound.min.y,
      x2 : bound.max.x,
      y2 : bound.max.y,
      width : bound.max.x - bound.min.x,
      height : bound.max.y - bound.min.y
    };
  };
  /**
   * @param {Object} o
   * @param {?} x
   * @param {?} y
   * @return {?}
   */
  R.isPointInsideBBox = function(o, x, y) {
    return x >= o.x && (x <= o.x2 && (y >= o.y && y <= o.y2));
  };
  /**
   * @param {Object} a
   * @param {Object} b
   * @return {?}
   */
  R.isBBoxIntersect = function(a, b) {
    /** @type {function (Object, ?, ?): ?} */
    var interpolationMethod = R.isPointInsideBBox;
    return interpolationMethod(b, a.x, a.y) || (interpolationMethod(b, a.x2, a.y) || (interpolationMethod(b, a.x, a.y2) || (interpolationMethod(b, a.x2, a.y2) || (interpolationMethod(a, b.x, b.y) || (interpolationMethod(a, b.x2, b.y) || (interpolationMethod(a, b.x, b.y2) || (interpolationMethod(a, b.x2, b.y2) || (a.x < b.x2 && a.x > b.x || b.x < a.x2 && b.x > a.x) && (a.y < b.y2 && a.y > b.y || b.y < a.y2 && b.y > a.y))))))));
  };
  /**
   * @param {Object} templateName
   * @param {Object} callback
   * @return {?}
   */
  R.pathIntersection = function(templateName, callback) {
    return render(templateName, callback);
  };
  /**
   * @param {Object} templateName
   * @param {Object} callback
   * @return {?}
   */
  R.pathIntersectionNumber = function(templateName, callback) {
    return render(templateName, callback, 1);
  };
  /**
   * @param {Object} data
   * @param {?} x
   * @param {?} cx
   * @return {?}
   */
  R.isPointInsidePath = function(data, x, cx) {
    var b = R.pathBBox(data);
    return R.isPointInsideBBox(b, x, cx) && render(data, [["M", x, cx], ["H", b.x2 + 10]], 1) % 2 == 1;
  };
  /**
   * @param {string} clone
   * @return {?}
   */
  R._removedFactory = function(clone) {
    return function() {
      $("raphael.log", null, "Rapha\u00ebl: you are calling to method \u201c" + clone + "\u201d of removed object", clone);
    };
  };
  /** @type {function (Object): ?} */
  var getActual = R.pathBBox = function(path) {
    var child = require(path);
    var i;
    var plen;
    var result;
    if (child.bbox) {
      return merge(child.bbox);
    }
    if (!path) {
      return{
        x : 0,
        y : 0,
        width : 0,
        height : 0,
        x2 : 0,
        y2 : 0
      };
    }
    path = path2curve(path);
    /** @type {number} */
    var a = 0;
    /** @type {number} */
    var val = 0;
    /** @type {Array} */
    var X = [];
    /** @type {Array} */
    var Y = [];
    var p;
    /** @type {number} */
    i = 0;
    plen = path.length;
    for (;i < plen;i++) {
      p = path[i];
      if (p[0] == "M") {
        a = p[1];
        val = p[2];
        X.push(a);
        Y.push(val);
      } else {
        result = curveDim(a, val, p[1], p[2], p[3], p[4], p[5], p[6]);
        X = X[concat](result.min.x, result.max.x);
        Y = Y[concat](result.min.y, result.max.y);
        a = p[5];
        val = p[6];
      }
    }
    var minX = min[apply](0, X);
    var y = min[apply](0, Y);
    var x = max[apply](0, X);
    var y2 = max[apply](0, Y);
    /** @type {number} */
    var deltaX = x - minX;
    /** @type {number} */
    var height = y2 - y;
    var o = {
      x : minX,
      y : y,
      x2 : x,
      y2 : y2,
      width : deltaX,
      height : height,
      cx : minX + deltaX / 2,
      cy : y + height / 2
    };
    return child.bbox = merge(o), o;
  };
  /**
   * @param {?} name
   * @return {?}
   */
  var equal = function(name) {
    var output = merge(name);
    return output.toString = R._path2string, output;
  };
  /** @type {function ((Array|string)): ?} */
  var animationElements = R._pathToRelative = function(p) {
    var result = require(p);
    var i;
    var valsLength;
    var r;
    var pa;
    var j;
    var paLength;
    var k;
    var kl;
    var len;
    if (result.rel) {
      return equal(result.rel);
    }
    if (!(R.is(p, selector) && R.is(p && p[0], selector))) {
      p = R.parsePathString(p);
    }
    /** @type {Array} */
    var res = [];
    /** @type {number} */
    var x = 0;
    /** @type {number} */
    var y = 0;
    /** @type {number} */
    var mx = 0;
    /** @type {number} */
    var my = 0;
    /** @type {number} */
    var mediaBlockCount = 0;
    if (p[0][0] == "M") {
      x = p[0][1];
      y = p[0][2];
      mx = x;
      my = y;
      mediaBlockCount++;
      res.push(["M", x, y]);
    }
    /** @type {number} */
    i = mediaBlockCount;
    valsLength = p.length;
    for (;i < valsLength;i++) {
      if (r = res[i] = [], pa = p[i], pa[0] != lowerCase.call(pa[0])) {
        /** @type {string} */
        r[0] = lowerCase.call(pa[0]);
        switch(r[0]) {
          case "a":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            /** @type {number} */
            r[6] = +(pa[6] - x).toFixed(3);
            /** @type {number} */
            r[7] = +(pa[7] - y).toFixed(3);
            break;
          case "v":
            /** @type {number} */
            r[1] = +(pa[1] - y).toFixed(3);
            break;
          case "m":
            mx = pa[1];
            my = pa[2];
          default:
            /** @type {number} */
            j = 1;
            paLength = pa.length;
            for (;j < paLength;j++) {
              /** @type {number} */
              r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
            }
          ;
        }
      } else {
        /** @type {Array} */
        r = res[i] = [];
        if (pa[0] == "m") {
          mx = pa[1] + x;
          my = pa[2] + y;
        }
        /** @type {number} */
        k = 0;
        kl = pa.length;
        for (;k < kl;k++) {
          res[i][k] = pa[k];
        }
      }
      len = res[i].length;
      switch(res[i][0]) {
        case "z":
          x = mx;
          y = my;
          break;
        case "h":
          x += +res[i][len - 1];
          break;
        case "v":
          y += +res[i][len - 1];
          break;
        default:
          x += +res[i][len - 2];
          y += +res[i][len - 1];
      }
    }
    return res.toString = R._path2string, result.rel = equal(res), res;
  };
  /** @type {function (Object): ?} */
  var isObject = R._pathToAbsolute = function(name) {
    var nodes = require(name);
    var suiteView;
    var r;
    var object;
    var n;
    var min;
    var data;
    var j;
    var length;
    var k;
    var kl;
    if (nodes.abs) {
      return equal(nodes.abs);
    }
    if (R.is(name, selector) && R.is(name && name[0], selector) || (name = R.parsePathString(name)), !name || !name.length) {
      return[["M", 0, 0]];
    }
    /** @type {Array} */
    var res = [];
    /** @type {number} */
    var x = 0;
    /** @type {number} */
    var y = 0;
    /** @type {number} */
    var mx = 0;
    /** @type {number} */
    var newY = 0;
    /** @type {number} */
    var step = 0;
    if (name[0][0] == "M") {
      /** @type {number} */
      x = +name[0][1];
      /** @type {number} */
      y = +name[0][2];
      /** @type {number} */
      mx = x;
      /** @type {number} */
      newY = y;
      step++;
      /** @type {Array} */
      res[0] = ["M", x, y];
    }
    /** @type {boolean} */
    suiteView = name.length == 3 && (name[0][0] == "M" && (name[1][0].toUpperCase() == "R" && name[2][0].toUpperCase() == "Z"));
    /** @type {number} */
    n = step;
    min = name.length;
    for (;n < min;n++) {
      if (res.push(r = []), object = name[n], object[0] != callback.call(object[0])) {
        /** @type {string} */
        r[0] = callback.call(object[0]);
        switch(r[0]) {
          case "A":
            r[1] = object[1];
            r[2] = object[2];
            r[3] = object[3];
            r[4] = object[4];
            r[5] = object[5];
            /** @type {number} */
            r[6] = +(object[6] + x);
            /** @type {number} */
            r[7] = +(object[7] + y);
            break;
          case "V":
            r[1] = +object[1] + y;
            break;
          case "H":
            r[1] = +object[1] + x;
            break;
          case "R":
            data = [x, y][concat](object.slice(1));
            /** @type {number} */
            j = 2;
            length = data.length;
            for (;j < length;j++) {
              data[j] = +data[j] + x;
              data[++j] = +data[j] + y;
            }
            res.pop();
            res = res[concat](getter(data, suiteView));
            break;
          case "M":
            mx = +object[1] + x;
            newY = +object[2] + y;
          default:
            /** @type {number} */
            j = 1;
            length = object.length;
            for (;j < length;j++) {
              r[j] = +object[j] + (j % 2 ? x : y);
            }
          ;
        }
      } else {
        if (object[0] == "R") {
          data = [x, y][concat](object.slice(1));
          res.pop();
          res = res[concat](getter(data, suiteView));
          r = ["R"][concat](object.slice(-2));
        } else {
          /** @type {number} */
          k = 0;
          kl = object.length;
          for (;k < kl;k++) {
            r[k] = object[k];
          }
        }
      }
      switch(r[0]) {
        case "Z":
          x = mx;
          y = newY;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          newY = r[r.length - 1];
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
    return res.toString = R._path2string, nodes.abs = equal(res), res;
  };
  /**
   * @param {?} x1
   * @param {?} x2
   * @param {?} dataAndEvents
   * @param {?} y1
   * @return {?}
   */
  var l2c = function(x1, x2, dataAndEvents, y1) {
    return[x1, x2, dataAndEvents, y1, dataAndEvents, y1];
  };
  /**
   * @param {number} y2
   * @param {number} x2
   * @param {number} ay
   * @param {number} ax
   * @param {number} y1
   * @param {number} x1
   * @return {?}
   */
  var q2c = function(y2, x2, ay, ax, y1, x1) {
    /** @type {number} */
    var _13 = 1 / 3;
    /** @type {number} */
    var _23 = 2 / 3;
    return[_13 * y2 + _23 * ay, _13 * x2 + _23 * ax, _13 * y1 + _23 * ay, _13 * x1 + _23 * ax, y1, x1];
  };
  /**
   * @param {number} x2
   * @param {number} y2
   * @param {number} rx
   * @param {number} ry
   * @param {number} angle
   * @param {number} large_arc_flag
   * @param {string} sweep_flag
   * @param {number} x1
   * @param {number} y1
   * @param {Array} recursive
   * @return {?}
   */
  var a2c = function(x2, y2, rx, ry, angle, large_arc_flag, sweep_flag, x1, y1, recursive) {
    /** @type {number} */
    var timeCheckInterval = PI * 120 / 180;
    /** @type {number} */
    var rad = PI / 180 * (+angle || 0);
    /** @type {Array} */
    var res = [];
    var xy;
    var rotate = cacher(function(x, y, rad) {
      /** @type {number} */
      var moveX = x * math.cos(rad) - y * math.sin(rad);
      /** @type {number} */
      var moveY = x * math.sin(rad) + y * math.cos(rad);
      return{
        x : moveX,
        y : moveY
      };
    });
    var df;
    var prevSources;
    var i;
    var valsLength;
    if (recursive) {
      f2 = recursive[0];
      f1 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    } else {
      xy = rotate(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      xy = rotate(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      /** @type {number} */
      var oi = math.cos(PI / 180 * angle);
      /** @type {number} */
      var si = math.sin(PI / 180 * angle);
      /** @type {number} */
      var xp = (x2 - x1) / 2;
      /** @type {number} */
      var yp = (y2 - y1) / 2;
      /** @type {number} */
      var cos = xp * xp / (rx * rx) + yp * yp / (ry * ry);
      if (cos > 1) {
        /** @type {number} */
        cos = math.sqrt(cos);
        /** @type {number} */
        rx = cos * rx;
        /** @type {number} */
        ry = cos * ry;
      }
      /** @type {number} */
      var a00 = rx * rx;
      /** @type {number} */
      var a11 = ry * ry;
      /** @type {number} */
      var f = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((a00 * a11 - a00 * yp * yp - a11 * xp * xp) / (a00 * yp * yp + a11 * xp * xp)));
      /** @type {number} */
      var cx = f * rx * yp / ry + (x2 + x1) / 2;
      /** @type {number} */
      var cy = f * -ry * xp / rx + (y2 + y1) / 2;
      /** @type {number} */
      var f2 = math.asin(((y2 - cy) / ry).toFixed(9));
      /** @type {number} */
      var f1 = math.asin(((y1 - cy) / ry).toFixed(9));
      /** @type {number} */
      f2 = x2 < cx ? PI - f2 : f2;
      /** @type {number} */
      f1 = x1 < cx ? PI - f1 : f1;
      if (f2 < 0) {
        /** @type {number} */
        f2 = PI * 2 + f2;
      }
      if (f1 < 0) {
        /** @type {number} */
        f1 = PI * 2 + f1;
      }
      if (sweep_flag) {
        if (f2 > f1) {
          /** @type {number} */
          f2 = f2 - PI * 2;
        }
      }
      if (!sweep_flag) {
        if (f1 > f2) {
          /** @type {number} */
          f1 = f1 - PI * 2;
        }
      }
    }
    if (df = f1 - f2, abs(df) > timeCheckInterval) {
      var f2old = f1;
      /** @type {number} */
      var x2old = x1;
      /** @type {number} */
      var y = y1;
      f1 = f2 + timeCheckInterval * (sweep_flag && f1 > f2 ? 1 : -1);
      x1 = cx + rx * math.cos(f1);
      y1 = cy + ry * math.sin(f1);
      res = a2c(x1, y1, rx, ry, angle, 0, sweep_flag, x2old, y, [f1, f2old, cx, cy]);
    }
    /** @type {number} */
    df = f1 - f2;
    /** @type {number} */
    var c2 = math.cos(f2);
    /** @type {number} */
    var s2 = math.sin(f2);
    /** @type {number} */
    var c1 = math.cos(f1);
    /** @type {number} */
    var s1 = math.sin(f1);
    /** @type {number} */
    var t = math.tan(df / 4);
    /** @type {number} */
    var hx = 4 / 3 * rx * t;
    /** @type {number} */
    var hy = 4 / 3 * ry * t;
    /** @type {Array} */
    var m4 = [x2, y2];
    /** @type {Array} */
    var m2 = [x2 + hx * s2, y2 - hy * c2];
    /** @type {Array} */
    var m3 = [x1 + hx * s1, y1 - hy * c1];
    /** @type {Array} */
    var s = [x1, y1];
    if (m2[0] = 2 * m4[0] - m2[0], m2[1] = 2 * m4[1] - m2[1], recursive) {
      return[m2, m3, s][concat](res);
    }
    res = [m2, m3, s][concat](res).join()[split](",");
    /** @type {Array} */
    prevSources = [];
    /** @type {number} */
    i = 0;
    valsLength = res.length;
    for (;i < valsLength;i++) {
      prevSources[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
    }
    return prevSources;
  };
  /**
   * @param {number} str
   * @param {number} c
   * @param {number} t
   * @param {number} d
   * @param {number} object
   * @param {number} collection
   * @param {number} deepDataAndEvents
   * @param {number} arg
   * @param {number} x
   * @return {?}
   */
  var error = function(str, c, t, d, object, collection, deepDataAndEvents, arg, x) {
    /** @type {number} */
    var b = 1 - x;
    return{
      x : pow(b, 3) * str + pow(b, 2) * 3 * x * t + b * 3 * x * x * object + pow(x, 3) * deepDataAndEvents,
      y : pow(b, 3) * c + pow(b, 2) * 3 * x * d + b * 3 * x * x * collection + pow(x, 3) * arg
    };
  };
  var curveDim = cacher(function(ms, b, delay, a, now, c, deepDataAndEvents, until) {
    /** @type {number} */
    var time = now - 2 * delay + ms - (deepDataAndEvents - 2 * now + delay);
    /** @type {number} */
    var a01 = 2 * (delay - ms) - 2 * (now - delay);
    /** @type {number} */
    var a11 = ms - delay;
    /** @type {number} */
    var ll = (-a01 + math.sqrt(a01 * a01 - 4 * time * a11)) / 2 / time;
    /** @type {number} */
    var speed = (-a01 - math.sqrt(a01 * a01 - 4 * time * a11)) / 2 / time;
    /** @type {Array} */
    var y = [b, until];
    /** @type {Array} */
    var x = [ms, deepDataAndEvents];
    var box;
    return abs(ll) > "1e12" && (ll = 0.5), abs(speed) > "1e12" && (speed = 0.5), ll > 0 && (ll < 1 && (box = error(ms, b, delay, a, now, c, deepDataAndEvents, until, ll), x.push(box.x), y.push(box.y))), speed > 0 && (speed < 1 && (box = error(ms, b, delay, a, now, c, deepDataAndEvents, until, speed), x.push(box.x), y.push(box.y))), time = c - 2 * a + b - (until - 2 * c + a), a01 = 2 * (a - b) - 2 * (c - a), a11 = b - a, ll = (-a01 + math.sqrt(a01 * a01 - 4 * time * a11)) / 2 / time, speed = (-a01 - 
    math.sqrt(a01 * a01 - 4 * time * a11)) / 2 / time, abs(ll) > "1e12" && (ll = 0.5), abs(speed) > "1e12" && (speed = 0.5), ll > 0 && (ll < 1 && (box = error(ms, b, delay, a, now, c, deepDataAndEvents, until, ll), x.push(box.x), y.push(box.y))), speed > 0 && (speed < 1 && (box = error(ms, b, delay, a, now, c, deepDataAndEvents, until, speed), x.push(box.x), y.push(box.y))), {
      min : {
        x : min[apply](0, x),
        y : min[apply](0, y)
      },
      max : {
        x : max[apply](0, x),
        y : max[apply](0, y)
      }
    };
  });
  var path2curve = R._path2curve = cacher(function(p, src) {
    var options = !src && require(p);
    var i;
    var length;
    if (!src && options.curve) {
      return equal(options.curve);
    }
    var path = isObject(p);
    var p2 = src && isObject(src);
    var attrs2 = {
      x : 0,
      y : 0,
      bx : 0,
      by : 0,
      X : 0,
      Y : 0,
      qx : null,
      qy : null
    };
    var attrs = {
      x : 0,
      y : 0,
      bx : 0,
      by : 0,
      X : 0,
      Y : 0,
      qx : null,
      qy : null
    };
    /**
     * @param {Array} path
     * @param {Object} d
     * @param {string} atype
     * @return {?}
     */
    var processPath = function(path, d, atype) {
      var b;
      var ny;
      if (!path) {
        return["C", d.x, d.y, d.x, d.y, d.x, d.y];
      }
      if (!(path[0] in {
        T : 1,
        Q : 1
      })) {
        /** @type {null} */
        d.qx = d.qy = null;
      }
      switch(path[0]) {
        case "M":
          d.X = path[1];
          d.Y = path[2];
          break;
        case "A":
          path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
          break;
        case "S":
          if (atype == "C" || atype == "S") {
            /** @type {number} */
            b = d.x * 2 - d.bx;
            /** @type {number} */
            ny = d.y * 2 - d.by;
          } else {
            b = d.x;
            ny = d.y;
          }
          path = ["C", b, ny][concat](path.slice(1));
          break;
        case "T":
          if (atype == "Q" || atype == "T") {
            /** @type {number} */
            d.qx = d.x * 2 - d.qx;
            /** @type {number} */
            d.qy = d.y * 2 - d.qy;
          } else {
            d.qx = d.x;
            d.qy = d.y;
          }
          path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
          break;
        case "Q":
          d.qx = path[1];
          d.qy = path[2];
          path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
          break;
        case "L":
          path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
          break;
        case "H":
          path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
          break;
        case "V":
          path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
          break;
        case "Z":
          path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
      }
      return path;
    };
    /**
     * @param {Array} str
     * @param {number} i
     * @return {undefined}
     */
    var write = function(str, i) {
      if (str[i].length > 7) {
        str[i].shift();
        var label = str[i];
        for (;label.length;) {
          str.splice(i++, 0, ["C"][concat](label.splice(0, 6)));
        }
        str.splice(i, 1);
        /** @type {number} */
        length = max(path.length, p2 && p2.length || 0);
      }
    };
    /**
     * @param {Array} path1
     * @param {Array} path2
     * @param {Object} a1
     * @param {?} a2
     * @param {number} i
     * @return {undefined}
     */
    var fixM = function(path1, path2, a1, a2, i) {
      if (path1) {
        if (path2) {
          if (path1[i][0] == "M") {
            if (path2[i][0] != "M") {
              path2.splice(i, 0, ["M", a2.x, a2.y]);
              /** @type {number} */
              a1.bx = 0;
              /** @type {number} */
              a1.by = 0;
              a1.x = path1[i][1];
              a1.y = path1[i][2];
              /** @type {number} */
              length = max(path.length, p2 && p2.length || 0);
            }
          }
        }
      }
    };
    /** @type {number} */
    i = 0;
    /** @type {number} */
    length = max(path.length, p2 && p2.length || 0);
    for (;i < length;i++) {
      path[i] = processPath(path[i], attrs2);
      write(path, i);
      if (p2) {
        p2[i] = processPath(p2[i], attrs);
      }
      if (p2) {
        write(p2, i);
      }
      fixM(path, p2, attrs2, attrs, i);
      fixM(p2, path, attrs, attrs2, i);
      var a = path[i];
      var seg2 = p2 && p2[i];
      var al = a.length;
      var seg2len = p2 && seg2.length;
      attrs2.x = a[al - 2];
      attrs2.y = a[al - 1];
      attrs2.bx = toFloat(a[al - 4]) || attrs2.x;
      attrs2.by = toFloat(a[al - 3]) || attrs2.y;
      attrs.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs.x);
      attrs.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs.y);
      attrs.x = p2 && seg2[seg2len - 2];
      attrs.y = p2 && seg2[seg2len - 1];
    }
    return p2 || (options.curve = equal(path)), p2 ? [path, p2] : path;
  }, null, equal);
  var fe = R._parseDots = cacher(function(directives) {
    var dot;
    var par;
    var start;
    var end;
    var j;
    var step;
    /** @type {Array} */
    var dots = [];
    /** @type {number} */
    var i = 0;
    var len = directives.length;
    for (;i < len;i++) {
      if (dot = {}, par = directives[i].match(/^([^:]*):?([\d\.]*)/), dot.color = R.getRGB(par[1]), dot.color.error) {
        return null;
      }
      dot.color = dot.color.hex;
      if (par[2]) {
        dot.offset = par[2] + "%";
      }
      dots.push(dot);
    }
    /** @type {number} */
    i = 1;
    /** @type {number} */
    len = dots.length - 1;
    for (;i < len;i++) {
      if (!dots[i].offset) {
        /** @type {number} */
        start = toFloat(dots[i - 1].offset || 0);
        /** @type {number} */
        end = 0;
        /** @type {number} */
        j = i + 1;
        for (;j < len;j++) {
          if (dots[j].offset) {
            end = dots[j].offset;
            break;
          }
        }
        if (!end) {
          /** @type {number} */
          end = 100;
          /** @type {number} */
          j = len;
        }
        /** @type {number} */
        end = toFloat(end);
        /** @type {number} */
        step = (end - start) / (j - i + 1);
        for (;i < j;i++) {
          start += step;
          /** @type {string} */
          dots[i].offset = start + "%";
        }
      }
    }
    return dots;
  });
  /** @type {function ((Object|string), Object): undefined} */
  var tear = R._tear = function(el, paper) {
    if (el == paper.top) {
      paper.top = el.prev;
    }
    if (el == paper.bottom) {
      paper.bottom = el.next;
    }
    if (el.next) {
      el.next.prev = el.prev;
    }
    if (el.prev) {
      el.prev.next = el.next;
    }
  };
  /** @type {function (Object, Window): undefined} */
  var ee = R._tofront = function(el, paper) {
    if (paper.top !== el) {
      tear(el, paper);
      /** @type {null} */
      el.next = null;
      el.prev = paper.top;
      /** @type {Object} */
      paper.top.next = el;
      /** @type {Object} */
      paper.top = el;
    }
  };
  /** @type {function (?, Object): undefined} */
  var oe = R._toback = function(el, paper) {
    if (paper.bottom !== el) {
      tear(el, paper);
      el.next = paper.bottom;
      /** @type {null} */
      el.prev = null;
      paper.bottom.prev = el;
      paper.bottom = el;
    }
  };
  /** @type {function (Object, (Object|string), Window): undefined} */
  var se = R._insertafter = function(el, el2, paper) {
    tear(el, paper);
    if (el2 == paper.top) {
      /** @type {Object} */
      paper.top = el;
    }
    if (el2.next) {
      /** @type {Object} */
      el2.next.prev = el;
    }
    el.next = el2.next;
    /** @type {(Object|string)} */
    el.prev = el2;
    /** @type {Object} */
    el2.next = el;
  };
  /** @type {function (?, (Object|string), Object): undefined} */
  var he = R._insertbefore = function(el, el2, paper) {
    tear(el, paper);
    if (el2 == paper.bottom) {
      paper.bottom = el;
    }
    if (el2.prev) {
      el2.prev.next = el;
    }
    el.prev = el2.prev;
    el2.prev = el;
    /** @type {(Object|string)} */
    el.next = el2;
  };
  /** @type {function (Object, Array): ?} */
  var fail = R.toMatrix = function(obj, v) {
    var actual = getActual(obj);
    var failuresLink = {
      _ : {
        transform : E
      },
      /**
       * @return {?}
       */
      getBBox : function() {
        return actual;
      }
    };
    return comp(failuresLink, v), failuresLink.matrix;
  };
  /** @type {function (Object, Array): ?} */
  var ce = R.transformPath = function(value, e) {
    return matrix(value, fail(value, e));
  };
  /** @type {function (Object, (Array|string)): ?} */
  var comp = R._extractTransform = function(el, x) {
    var i;
    var valsLength;
    if (x == null) {
      return el._.transform;
    }
    /** @type {string} */
    x = f(x).replace(/\.{3}|\u2026/g, el._.transform || E);
    var comparisons = R.parseTransformString(x);
    /** @type {number} */
    var deg = 0;
    /** @type {number} */
    var j = 0;
    /** @type {number} */
    var s = 0;
    /** @type {number} */
    var sx = 1;
    /** @type {number} */
    var sy = 1;
    var _ = el._;
    var m = new Matrix;
    if (_.transform = comparisons || [], comparisons) {
      /** @type {number} */
      i = 0;
      valsLength = comparisons.length;
      for (;i < valsLength;i++) {
        var t = comparisons[i];
        var tlen = t.length;
        /** @type {string} */
        var command = f(t[0]).toLowerCase();
        /** @type {boolean} */
        var isXML = t[0] != command;
        var ret = isXML ? m.invert() : 0;
        var x1;
        var y1;
        var x2;
        var y2;
        var details;
        if (command == "t" && tlen == 3) {
          if (isXML) {
            x1 = ret.x(0, 0);
            y1 = ret.y(0, 0);
            x2 = ret.x(t[1], t[2]);
            y2 = ret.y(t[1], t[2]);
            m.translate(x2 - x1, y2 - y1);
          } else {
            m.translate(t[1], t[2]);
          }
        } else {
          if (command == "r") {
            if (tlen == 2) {
              details = details || el.getBBox(1);
              m.rotate(t[1], details.x + details.width / 2, details.y + details.height / 2);
              deg += t[1];
            } else {
              if (tlen == 4) {
                if (isXML) {
                  x2 = ret.x(t[2], t[3]);
                  y2 = ret.y(t[2], t[3]);
                  m.rotate(t[1], x2, y2);
                } else {
                  m.rotate(t[1], t[2], t[3]);
                }
                deg += t[1];
              }
            }
          } else {
            if (command == "s") {
              if (tlen == 2 || tlen == 3) {
                details = details || el.getBBox(1);
                m.scale(t[1], t[tlen - 1], details.x + details.width / 2, details.y + details.height / 2);
                sx *= t[1];
                sy *= t[tlen - 1];
              } else {
                if (tlen == 5) {
                  if (isXML) {
                    x2 = ret.x(t[3], t[4]);
                    y2 = ret.y(t[3], t[4]);
                    m.scale(t[1], t[2], x2, y2);
                  } else {
                    m.scale(t[1], t[2], t[3], t[4]);
                  }
                  sx *= t[1];
                  sy *= t[2];
                }
              }
            } else {
              if (command == "m") {
                if (tlen == 7) {
                  m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                }
              }
            }
          }
        }
        /** @type {number} */
        _.dirtyT = 1;
        el.matrix = m;
      }
    }
    el.matrix = m;
    /** @type {number} */
    _.sx = sx;
    /** @type {number} */
    _.sy = sy;
    /** @type {number} */
    _.deg = deg;
    _.dx = j = m.e;
    _.dy = s = m.f;
    if (sx == 1 && (sy == 1 && (!deg && _.bbox))) {
      _.bbox.x += +j;
      _.bbox.y += +s;
    } else {
      /** @type {number} */
      _.dirtyT = 1;
    }
  };
  /**
   * @param {Array} str
   * @return {?}
   */
  var transform2matrix = function(str) {
    var label = str[0];
    switch(label.toLowerCase()) {
      case "t":
        return[label, 0, 0];
      case "m":
        return[label, 1, 0, 0, 1, 0, 0];
      case "r":
        return str.length == 4 ? [label, 0, str[2], str[3]] : [label, 0];
      case "s":
        return str.length == 5 ? [label, 1, 1, str[3], str[4]] : str.length == 3 ? [label, 1, 1] : [label, 1];
    }
  };
  /** @type {function (Array, (Array|string)): ?} */
  var _update = R._equaliseTransform = function(value, cell) {
    /** @type {string} */
    cell = f(cell).replace(/\.{3}|\u2026/g, value);
    value = R.parseTransformString(value) || [];
    cell = R.parseTransformString(cell) || [];
    /** @type {number} */
    var n = max(value.length, cell.length);
    /** @type {Array} */
    var from = [];
    /** @type {Array} */
    var parent = [];
    /** @type {number} */
    var c = 0;
    var i;
    var length;
    var self;
    var b;
    for (;c < n;c++) {
      if (self = value[c] || transform2matrix(cell[c]), b = cell[c] || transform2matrix(self), self[0] != b[0] || (self[0].toLowerCase() == "r" && (self[2] != b[2] || self[3] != b[3]) || self[0].toLowerCase() == "s" && (self[3] != b[3] || self[4] != b[4]))) {
        return;
      }
      /** @type {Array} */
      from[c] = [];
      /** @type {Array} */
      parent[c] = [];
      /** @type {number} */
      i = 0;
      /** @type {number} */
      length = max(self.length, b.length);
      for (;i < length;i++) {
        if (i in self) {
          from[c][i] = self[i];
        }
        if (i in b) {
          parent[c][i] = b[i];
        }
      }
    }
    return{
      from : from,
      to : parent
    };
  };
  /**
   * @param {?} x
   * @param {number} value
   * @param {number} side
   * @param {number} rowHeight
   * @return {?}
   */
  R._getContainer = function(x, value, side, rowHeight) {
    var container;
    if (container = rowHeight == null && !R.is(x, "object") ? win.doc.getElementById(x) : x, container != null) {
      return container.tagName ? value == null ? {
        container : container,
        width : container.style.pixelWidth || container.offsetWidth,
        height : container.style.pixelHeight || container.offsetHeight
      } : {
        container : container,
        width : value,
        height : side
      } : {
        container : 1,
        x : x,
        y : value,
        width : side,
        height : rowHeight
      };
    }
  };
  /** @type {function ((Array|string)): ?} */
  R.pathToRelative = animationElements;
  R._engine = {};
  R.path2curve = path2curve;
  /**
   * @param {string} value
   * @param {Function} name
   * @param {string} s
   * @param {string} index
   * @param {number} a
   * @param {Function} b
   * @return {?}
   */
  R.matrix = function(value, name, s, index, a, b) {
    return new Matrix(value, name, s, index, a, b);
  };
  (function(matrix) {
    /**
     * @param {Array} a
     * @return {?}
     */
    function norm(a) {
      return a[0] * a[0] + a[1] * a[1];
    }
    /**
     * @param {Array} a
     * @return {undefined}
     */
    function normalize(a) {
      /** @type {number} */
      var mag = math.sqrt(norm(a));
      if (a[0]) {
        a[0] /= mag;
      }
      if (a[1]) {
        a[1] /= mag;
      }
    }
    /**
     * @param {Object} object
     * @param {number} mayParseLabeledStatementInstead
     * @param {number} recurring
     * @param {number} dataAndEvents
     * @param {number} v00
     * @param {number} v1
     * @return {undefined}
     */
    matrix.add = function(object, mayParseLabeledStatementInstead, recurring, dataAndEvents, v00, v1) {
      /** @type {Array} */
      var paths = [[], [], []];
      /** @type {Array} */
      var delta = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]];
      /** @type {Array} */
      var cache = [[object, recurring, v00], [mayParseLabeledStatementInstead, dataAndEvents, v1], [0, 0, 1]];
      var j;
      var i;
      var k;
      var v0;
      if (object) {
        if (object instanceof Matrix) {
          /** @type {Array} */
          cache = [[object.a, object.c, object.e], [object.b, object.d, object.f], [0, 0, 1]];
        }
      }
      /** @type {number} */
      j = 0;
      for (;j < 3;j++) {
        /** @type {number} */
        i = 0;
        for (;i < 3;i++) {
          /** @type {number} */
          v0 = 0;
          /** @type {number} */
          k = 0;
          for (;k < 3;k++) {
            v0 += delta[j][k] * cache[k][i];
          }
          /** @type {number} */
          paths[j][i] = v0;
        }
      }
      this.a = paths[0][0];
      this.b = paths[1][0];
      this.c = paths[0][1];
      this.d = paths[1][1];
      this.e = paths[0][2];
      this.f = paths[1][2];
    };
    /**
     * @return {?}
     */
    matrix.invert = function() {
      var me = this;
      /** @type {number} */
      var x = me.a * me.d - me.b * me.c;
      return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
    };
    /**
     * @return {?}
     */
    matrix.clone = function() {
      return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
    };
    /**
     * @param {number} x
     * @param {number} y
     * @return {undefined}
     */
    matrix.translate = function(x, y) {
      this.add(1, 0, 0, 1, x, y);
    };
    /**
     * @param {string} s
     * @param {string} dataAndEvents
     * @param {Window} x
     * @param {Window} y
     * @return {undefined}
     */
    matrix.scale = function(s, dataAndEvents, x, y) {
      if (dataAndEvents == null) {
        /** @type {string} */
        dataAndEvents = s;
      }
      if (x || y) {
        this.add(1, 0, 0, 1, x, y);
      }
      this.add(s, 0, 0, dataAndEvents, 0, 0);
      if (x || y) {
        this.add(1, 0, 0, 1, -x, -y);
      }
    };
    /**
     * @param {number} angle
     * @param {number} x
     * @param {number} y
     * @return {undefined}
     */
    matrix.rotate = function(angle, x, y) {
      angle = R.rad(angle);
      x = x || 0;
      y = y || 0;
      /** @type {number} */
      var node = +math.cos(angle).toFixed(9);
      /** @type {number} */
      var sin = +math.sin(angle).toFixed(9);
      this.add(node, sin, -sin, node, x, y);
      this.add(1, 0, 0, 1, -x, -y);
    };
    /**
     * @param {string} x
     * @param {Function} y
     * @return {?}
     */
    matrix.x = function(x, y) {
      return x * this.a + y * this.c + this.e;
    };
    /**
     * @param {string} x
     * @param {number} y
     * @return {?}
     */
    matrix.y = function(x, y) {
      return x * this.b + y * this.d + this.f;
    };
    /**
     * @param {number} expectedNumberOfNonCommentArgs
     * @return {?}
     */
    matrix.get = function(expectedNumberOfNonCommentArgs) {
      return+this[f.fromCharCode(97 + expectedNumberOfNonCommentArgs)].toFixed(4);
    };
    /**
     * @return {?}
     */
    matrix.toString = function() {
      return R.svg ? "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" : [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
    };
    /**
     * @return {?}
     */
    matrix.toFilter = function() {
      return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) + ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) + ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
    };
    /**
     * @return {?}
     */
    matrix.offset = function() {
      return[this.e.toFixed(4), this.f.toFixed(4)];
    };
    /**
     * @return {?}
     */
    matrix.split = function() {
      var out = {};
      var row;
      var sin;
      var cos;
      return out.dx = this.e, out.dy = this.f, row = [[this.a, this.c], [this.b, this.d]], out.scalex = math.sqrt(norm(row[0])), normalize(row[0]), out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1], row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear], out.scaley = math.sqrt(norm(row[1])), normalize(row[1]), out.shear /= out.scaley, sin = -row[0][1], cos = row[1][1], cos < 0 ? (out.rotate = R.deg(math.acos(cos)), sin < 0 && (out.rotate = 360 - out.rotate)) : out.rotate = 
      R.deg(math.asin(sin)), out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate), out.isSuperSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate), out.noRotation = !+out.shear.toFixed(9) && !out.rotate, out;
    };
    /**
     * @param {Object} shorter
     * @return {?}
     */
    matrix.toTransformString = function(shorter) {
      var s = shorter || this[split]();
      return s.isSimple ? (s.scalex = +s.scalex.toFixed(4), s.scaley = +s.scaley.toFixed(4), s.rotate = +s.rotate.toFixed(4), (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) + (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) + (s.rotate ? "r" + [s.rotate, 0, 0] : E)) : "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
    };
  })(Matrix.prototype);
  /** @type {(Array.<string>|null)} */
  bt = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
  /** @type {function (): undefined} */
  paper.safari = navigator.vendor == "Apple Computer, Inc." && (bt && bt[1] < 4 || navigator.platform.slice(0, 2) == "iP") || navigator.vendor == "Google Inc." && (bt && bt[1] < 8) ? function() {
    var selfObj = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
      stroke : "none"
    });
    setTimeout(function() {
      selfObj.remove();
    });
  } : safari;
  /**
   * @return {undefined}
   */
  var preventDefault = function() {
    /** @type {boolean} */
    this.returnValue = false;
  };
  /**
   * @return {?}
   */
  var preventTouch = function() {
    return this.originalEvent.preventDefault();
  };
  /**
   * @return {undefined}
   */
  var stopPropagation = function() {
    /** @type {boolean} */
    this.cancelBubble = true;
  };
  /**
   * @return {?}
   */
  var stopTouch = function() {
    return this.originalEvent.stopPropagation();
  };
  /**
   * @param {Object} event
   * @return {?}
   */
  var fix = function(event) {
    var scrOfY = win.doc.documentElement.scrollTop || win.doc.body.scrollTop;
    var body_scrollLeft = win.doc.documentElement.scrollLeft || win.doc.body.scrollLeft;
    return{
      x : event.clientX + body_scrollLeft,
      y : event.clientY + scrOfY
    };
  };
  var addEvent = function() {
    return win.doc.addEventListener ? function(element, type, self, bind) {
      /**
       * @param {Object} event
       * @return {?}
       */
      var handler = function(event) {
        var data = fix(event);
        return self.call(bind, event, data.x, data.y);
      };
      var touchStart;
      return element.addEventListener(type, handler, false), isTouchDevice && (events[type] && (touchStart = function(event) {
        var data = fix(event);
        /** @type {Object} */
        var originalEvent = event;
        /** @type {number} */
        var i = 0;
        var padLength = event.targetTouches && event.targetTouches.length;
        for (;i < padLength;i++) {
          if (event.targetTouches[i].target == element) {
            event = event.targetTouches[i];
            event.originalEvent = originalEvent;
            /** @type {function (): ?} */
            event.preventDefault = preventTouch;
            /** @type {function (): ?} */
            event.stopPropagation = stopTouch;
            break;
          }
        }
        return self.call(bind, event, data.x, data.y);
      }, element.addEventListener(events[type], touchStart, false))), function() {
        return element.removeEventListener(type, handler, false), isTouchDevice && (events[type] && element.removeEventListener(events[type], handler, false)), true;
      };
    } : win.doc.attachEvent ? function(o, evtName, callback, T) {
      /**
       * @param {Event} e
       * @return {?}
       */
      var f = function(e) {
        e = e || win.win.event;
        var h = win.doc.documentElement.scrollTop || win.doc.body.scrollTop;
        var sLft = win.doc.documentElement.scrollLeft || win.doc.body.scrollLeft;
        var value = e.clientX + sLft;
        var info = e.clientY + h;
        return e.preventDefault = e.preventDefault || preventDefault, e.stopPropagation = e.stopPropagation || stopPropagation, callback.call(T, e, value, info);
      };
      return o.attachEvent("on" + evtName, f), function() {
        return o.detachEvent("on" + evtName, f), true;
      };
    } : void 0;
  }();
  /** @type {Array} */
  var drag = [];
  /**
   * @param {Object} e
   * @return {undefined}
   */
  var dragMove = function(e) {
    var x = e.clientX;
    var posY = e.clientY;
    var height = win.doc.documentElement.scrollTop || win.doc.body.scrollTop;
    var chunk = win.doc.documentElement.scrollLeft || win.doc.body.scrollLeft;
    var dragi;
    var j = drag.length;
    var i;
    var touch;
    for (;j--;) {
      if (dragi = drag[j], isTouchDevice && e.touches) {
        i = e.touches.length;
        for (;i--;) {
          if (touch = e.touches[i], touch.identifier == dragi.el._drag.id) {
            x = touch.clientX;
            posY = touch.clientY;
            (e.originalEvent ? e.originalEvent : e).preventDefault();
            break;
          }
        }
      } else {
        e.preventDefault();
      }
      var node = dragi.el.node;
      var formatter;
      var sibling = node.nextSibling;
      var parent = node.parentNode;
      var gutterDisplay = node.style.display;
      if (win.win.opera) {
        parent.removeChild(node);
      }
      /** @type {string} */
      node.style.display = "none";
      formatter = dragi.el.paper.getElementByPoint(x, posY);
      node.style.display = gutterDisplay;
      if (win.win.opera) {
        if (sibling) {
          parent.insertBefore(node, sibling);
        } else {
          parent.appendChild(node);
        }
      }
      if (formatter) {
        $("raphael.drag.over." + dragi.el.id, dragi.el, formatter);
      }
      x += chunk;
      posY += height;
      $("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, posY - dragi.el._drag.y, x, posY, e);
    }
  };
  /**
   * @param {?} module
   * @return {undefined}
   */
  var dragUp = function(module) {
    R.unmousemove(dragMove).unmouseup(dragUp);
    var j = drag.length;
    var dragi;
    for (;j--;) {
      dragi = drag[j];
      dragi.el._drag = {};
      $("raphael.drag.end." + dragi.el.id, dragi.end_scope || (dragi.start_scope || (dragi.move_scope || dragi.el)), module);
    }
    /** @type {Array} */
    drag = [];
  };
  var self = R.el = {};
  i = codeSegments.length;
  for (;i--;) {
    (function(eventName) {
      /** @type {function (number, number): ?} */
      R[eventName] = self[eventName] = function(fn, dataAndEvents) {
        return R.is(fn, "function") && (this.events = this.events || [], this.events.push({
          name : eventName,
          f : fn,
          unbind : addEvent(this.shape || (this.node || win.doc), eventName, fn, dataAndEvents || this)
        })), this;
      };
      /** @type {function (?): ?} */
      R["un" + eventName] = self["un" + eventName] = function(fn) {
        var events = this.events || [];
        var l = events.length;
        for (;l--;) {
          if (events[l].name == eventName) {
            if (R.is(fn, "undefined") || events[l].f == fn) {
              events[l].unbind();
              events.splice(l, 1);
              if (!events.length) {
                delete this.events;
              }
            }
          }
        }
        return this;
      };
    })(codeSegments[i]);
  }
  /**
   * @param {Object} key
   * @param {?} value
   * @return {?}
   */
  self.data = function(key, value) {
    var flags = args[this.id] = args[this.id] || {};
    var i;
    if (arguments.length == 0) {
      return flags;
    }
    if (arguments.length == 1) {
      if (R.is(key, "object")) {
        for (i in key) {
          if (key[has](i)) {
            this.data(i, key[i]);
          }
        }
        return this;
      }
      return $("raphael.data.get." + this.id, this, flags[key], key), flags[key];
    }
    return flags[key] = value, $("raphael.data.set." + this.id, this, value, key), this;
  };
  /**
   * @param {(Object|boolean|number|string)} key
   * @return {?}
   */
  self.removeData = function(key) {
    return key == null ? args[this.id] = {} : args[this.id] && delete args[this.id][key], this;
  };
  /**
   * @return {?}
   */
  self.getData = function() {
    return merge(args[this.id] || {});
  };
  /**
   * @param {?} f_in
   * @param {?} e
   * @param {undefined} scope_in
   * @param {Object} scope_out
   * @return {?}
   */
  self.hover = function(f_in, e, scope_in, scope_out) {
    return this.mouseover(f_in, scope_in).mouseout(e, scope_out || scope_in);
  };
  /**
   * @param {?} f_in
   * @param {?} f_out
   * @return {?}
   */
  self.unhover = function(f_in, f_out) {
    return this.unmouseover(f_in).unmouseout(f_out);
  };
  /** @type {Array} */
  draggable = [];
  /**
   * @param {?} arg
   * @param {?} name
   * @param {?} opts
   * @param {Object} move_scope
   * @param {number} start_scope
   * @param {Object} end_scope
   * @return {?}
   */
  self.drag = function(arg, name, opts, move_scope, start_scope, end_scope) {
    /**
     * @param {Object} e
     * @return {undefined}
     */
    function start(e) {
      var i;
      var ev;
      (e.originalEvent || e).preventDefault();
      var clientX = e.clientX;
      var clientY = e.clientY;
      var scrollY = win.doc.documentElement.scrollTop || win.doc.body.scrollTop;
      var scrollX = win.doc.documentElement.scrollLeft || win.doc.body.scrollLeft;
      if (this._drag.id = e.identifier, isTouchDevice && e.touches) {
        i = e.touches.length;
        for (;i--;) {
          if (ev = e.touches[i], this._drag.id = ev.identifier, ev.identifier == this._drag.id) {
            clientX = ev.clientX;
            clientY = ev.clientY;
            break;
          }
        }
      }
      this._drag.x = clientX + scrollX;
      this._drag.y = clientY + scrollY;
      if (!drag.length) {
        R.mousemove(dragMove).mouseup(dragUp);
      }
      drag.push({
        el : this,
        move_scope : move_scope,
        start_scope : start_scope,
        end_scope : end_scope
      });
      if (name) {
        $.on("raphael.drag.start." + this.id, name);
      }
      if (arg) {
        $.on("raphael.drag.move." + this.id, arg);
      }
      if (opts) {
        $.on("raphael.drag.end." + this.id, opts);
      }
      $("raphael.drag.start." + this.id, start_scope || (move_scope || this), e.clientX + scrollX, e.clientY + scrollY, e);
    }
    return this._drag = {}, draggable.push({
      el : this,
      /** @type {function (Object): undefined} */
      start : start
    }), this.mousedown(start), this;
  };
  /**
   * @param {?} name
   * @return {undefined}
   */
  self.onDragOver = function(name) {
    if (name) {
      $.on("raphael.drag.over." + this.id, name);
    } else {
      $.unbind("raphael.drag.over." + this.id);
    }
  };
  /**
   * @return {undefined}
   */
  self.undrag = function() {
    var i = draggable.length;
    for (;i--;) {
      if (draggable[i].el == this) {
        this.unmousedown(draggable[i].start);
        draggable.splice(i, 1);
        $.unbind("raphael.drag.*." + this.id);
      }
    }
    if (!draggable.length) {
      R.unmousemove(dragMove).unmouseup(dragUp);
    }
    /** @type {Array} */
    drag = [];
  };
  /**
   * @param {number} dataAndEvents
   * @param {number} node
   * @param {number} x
   * @return {?}
   */
  paper.circle = function(dataAndEvents, node, x) {
    var copies = R._engine.circle(this, dataAndEvents || 0, node || 0, x || 0);
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {number} w
   * @param {number} width
   * @param {number} height
   * @param {number} ry
   * @param {number} x
   * @return {?}
   */
  paper.rect = function(w, width, height, ry, x) {
    var copies = R._engine.rect(this, w || 0, width || 0, height || 0, ry || 0, x || 0);
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {number} dataAndEvents
   * @param {number} rx
   * @param {number} ry
   * @param {number} node
   * @return {?}
   */
  paper.ellipse = function(dataAndEvents, rx, ry, node) {
    var copies = R._engine.ellipse(this, dataAndEvents || 0, rx || 0, ry || 0, node || 0);
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {string} name
   * @return {?}
   */
  paper.path = function(name) {
    if (!!name) {
      if (!R.is(name, string)) {
        if (!R.is(name[0], selector)) {
          name += E;
        }
      }
    }
    var copies = R._engine.path(R.format[apply](R, arguments), this);
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {string} dataAndEvents
   * @param {number} image
   * @param {number} text
   * @param {number} x
   * @param {number} node
   * @return {?}
   */
  paper.image = function(dataAndEvents, image, text, x, node) {
    var copies = R._engine.image(this, dataAndEvents || "about:blank", image || 0, text || 0, x || 0, node || 0);
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {string} value
   * @param {Function} name
   * @param {?} id
   * @return {?}
   */
  paper.text = function(value, name, id) {
    var copies = R._engine.text(this, value || 0, name || 0, f(id));
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {?} v
   * @return {?}
   */
  paper.set = function(v) {
    if (!R.is(v, "array")) {
      /** @type {Array.<?>} */
      v = Array.prototype.splice.call(arguments, 0, arguments.length);
    }
    var d = new Set(v);
    return this.__set__ && this.__set__.push(d), d.paper = this, d.type = "set", d;
  };
  /**
   * @param {?} offset
   * @return {undefined}
   */
  paper.setStart = function(offset) {
    this.__set__ = offset || this.set();
  };
  /**
   * @return {?}
   */
  paper.setFinish = function() {
    var __set__ = this.__set__;
    return delete this.__set__, __set__;
  };
  /**
   * @param {?} width
   * @param {?} height
   * @return {?}
   */
  paper.setSize = function(width, height) {
    return R._engine.setSize.call(this, width, height);
  };
  /**
   * @param {?} mapper
   * @param {?} w
   * @param {?} capture
   * @param {?} h
   * @param {?} height
   * @return {?}
   */
  paper.setViewBox = function(mapper, w, capture, h, height) {
    return R._engine.setViewBox.call(this, mapper, w, capture, h, height);
  };
  /** @type {null} */
  paper.top = paper.bottom = null;
  /** @type {function (?): ?} */
  paper.raphael = R;
  /**
   * @param {HTMLElement} element
   * @return {?}
   */
  getOffset = function(element) {
    var otherElementRect = element.getBoundingClientRect();
    var doc = element.ownerDocument;
    var body = doc.body;
    var docElem = doc.documentElement;
    var clientTop = docElem.clientTop || (body.clientTop || 0);
    var clientLeft = docElem.clientLeft || (body.clientLeft || 0);
    /** @type {number} */
    var top = otherElementRect.top + (win.win.pageYOffset || (docElem.scrollTop || body.scrollTop)) - clientTop;
    /** @type {number} */
    var left = otherElementRect.left + (win.win.pageXOffset || (docElem.scrollLeft || body.scrollLeft)) - clientLeft;
    return{
      y : top,
      x : left
    };
  };
  /**
   * @param {number} x
   * @param {number} y
   * @return {?}
   */
  paper.getElementByPoint = function(x, y) {
    var self = this;
    var element = self.canvas;
    var node = win.doc.elementFromPoint(x, y);
    var offset;
    var next;
    var opt_nodes;
    if (win.win.opera && (node.tagName == "svg" && (offset = getOffset(element), next = element.createSVGRect(), next.x = x - offset.x, next.y = y - offset.y, next.width = next.height = 1, opt_nodes = element.getIntersectionList(next, null), opt_nodes.length && (node = opt_nodes[opt_nodes.length - 1]))), !node) {
      return null;
    }
    for (;node.parentNode && (node != element.parentNode && !node.raphael);) {
      node = node.parentNode;
    }
    return node == self.canvas.parentNode && (node = element), node && node.raphael ? self.getById(node.raphaelid) : null;
  };
  /**
   * @param {Object} _super
   * @return {?}
   */
  paper.getElementsByBBox = function(_super) {
    var bg = this.set();
    return this.forEach(function(el) {
      if (R.isBBoxIntersect(el.getBBox(), _super)) {
        bg.push(el);
      }
    }), bg;
  };
  /**
   * @param {?} id
   * @return {?}
   */
  paper.getById = function(id) {
    var item = this.bottom;
    for (;item;) {
      if (item.id == id) {
        return item;
      }
      item = item.next;
    }
    return null;
  };
  /**
   * @param {Function} block
   * @param {?} thisObject
   * @return {?}
   */
  paper.forEach = function(block, thisObject) {
    var sibling = this.bottom;
    for (;sibling;) {
      if (block.call(thisObject, sibling) === false) {
        return this;
      }
      sibling = sibling.next;
    }
    return this;
  };
  /**
   * @param {string} x
   * @param {string} y
   * @return {?}
   */
  paper.getElementsByPoint = function(x, y) {
    var paragraph = this.set();
    return this.forEach(function(child) {
      if (child.isPointInside(x, y)) {
        paragraph.push(child);
      }
    }), paragraph;
  };
  /**
   * @param {string} x
   * @param {string} y
   * @return {?}
   */
  self.isPointInside = function(x, y) {
    var pdataCur = this.realPath = VALUE[this.type](this);
    return this.attr("transform") && (this.attr("transform").length && (pdataCur = R.transformPath(pdataCur, this.attr("transform")))), R.isPointInsidePath(pdataCur, x, y);
  };
  /**
   * @param {number} dataAndEvents
   * @return {?}
   */
  self.getBBox = function(dataAndEvents) {
    if (this.removed) {
      return{};
    }
    var _ = this._;
    return dataAndEvents ? ((_.dirty || !_.bboxwt) && (this.realPath = VALUE[this.type](this), _.bboxwt = getActual(this.realPath), _.bboxwt.toString = x_y_w_h, _.dirty = 0), _.bboxwt) : ((_.dirty || (_.dirtyT || !_.bbox)) && ((_.dirty || !this.realPath) && (_.bboxwt = 0, this.realPath = VALUE[this.type](this)), _.bbox = getActual(matrix(this.realPath, this.matrix)), _.bbox.toString = x_y_w_h, _.dirty = _.dirtyT = 0), _.bbox);
  };
  /**
   * @return {?}
   */
  self.clone = function() {
    if (this.removed) {
      return null;
    }
    var copies = this.paper[this.type]().attr(this.attr());
    return this.__set__ && this.__set__.push(copies), copies;
  };
  /**
   * @param {Object} params
   * @return {?}
   */
  self.glow = function(params) {
    var i;
    if (this.type == "text") {
      return null;
    }
    params = params || {};
    var options = {
      width : (params.width || 10) + (+this.attr("stroke-width") || 1),
      fill : params.fill || false,
      opacity : params.opacity || 0.5,
      offsetx : params.offsetx || 0,
      offsety : params.offsety || 0,
      color : params.color || "#000"
    };
    /** @type {number} */
    var steps = options.width / 2;
    var canvas = this.paper;
    var update = canvas.set();
    var value = this.realPath || VALUE[this.type](this);
    value = this.matrix ? matrix(value, this.matrix) : value;
    /** @type {number} */
    i = 1;
    for (;i < steps + 1;i++) {
      update.push(canvas.path(value).attr({
        stroke : options.color,
        fill : options.fill ? options.color : "none",
        "stroke-linejoin" : "round",
        "stroke-linecap" : "round",
        "stroke-width" : +(options.width / steps * i).toFixed(3),
        opacity : +(options.opacity / steps).toFixed(3)
      }));
    }
    return update.insertBefore(this).translate(options.offsetx, options.offsety);
  };
  /**
   * @param {number} obj
   * @param {number} data
   * @param {number} callback
   * @param {number} j
   * @param {number} next
   * @param {number} opt_key
   * @param {number} action
   * @param {number} col
   * @param {number} ctor
   * @return {?}
   */
  var get = function(obj, data, callback, j, next, opt_key, action, col, ctor) {
    return ctor == null ? fn(obj, data, callback, j, next, opt_key, action, col) : R.findDotsAtSegment(obj, data, callback, j, next, opt_key, action, col, handler(obj, data, callback, j, next, opt_key, action, col, ctor));
  };
  /**
   * @param {number} escape
   * @param {Object} dataAndEvents
   * @return {?}
   */
  var update = function(escape, dataAndEvents) {
    return function(path, ignoreMethodDoesntExist, deepDataAndEvents) {
      var i;
      var plen;
      path = path2curve(path);
      var parent;
      var key;
      var p;
      var value;
      /** @type {string} */
      var pos = "";
      var sel = {};
      var obj;
      /** @type {number} */
      var str = 0;
      /** @type {number} */
      i = 0;
      plen = path.length;
      for (;i < plen;i++) {
        if (p = path[i], p[0] == "M") {
          /** @type {number} */
          parent = +p[1];
          /** @type {number} */
          key = +p[2];
        } else {
          if (value = get(parent, key, p[1], p[2], p[3], p[4], p[5], p[6]), str + value > ignoreMethodDoesntExist) {
            if (dataAndEvents && !sel.start) {
              if (obj = get(parent, key, p[1], p[2], p[3], p[4], p[5], p[6], ignoreMethodDoesntExist - str), pos += ["C" + obj.start.x, obj.start.y, obj.m.x, obj.m.y, obj.x, obj.y], deepDataAndEvents) {
                return pos;
              }
              /** @type {string} */
              sel.start = pos;
              /** @type {string} */
              pos = ["M" + obj.x, obj.y + "C" + obj.n.x, obj.n.y, obj.end.x, obj.end.y, p[5], p[6]].join();
              str += value;
              /** @type {number} */
              parent = +p[5];
              /** @type {number} */
              key = +p[6];
              continue;
            }
            if (!escape && !dataAndEvents) {
              return obj = get(parent, key, p[1], p[2], p[3], p[4], p[5], p[6], ignoreMethodDoesntExist - str), {
                x : obj.x,
                y : obj.y,
                alpha : obj.alpha
              };
            }
          }
          str += value;
          /** @type {number} */
          parent = +p[5];
          /** @type {number} */
          key = +p[6];
        }
        pos += p.shift() + p;
      }
      return sel.end = pos, obj = escape ? str : dataAndEvents ? sel : R.findDotsAtSegment(parent, key, p[0], p[1], p[2], p[3], p[4], p[5], 1), obj.alpha && (obj = {
        x : obj.x,
        y : obj.y,
        alpha : obj.alpha
      }), obj;
    };
  };
  var isUndefined = update(1);
  var a = update();
  var lookup = update(0, 1);
  R.getTotalLength = isUndefined;
  R.getPointAtLength = a;
  /**
   * @param {?} name
   * @param {number} path
   * @param {?} to
   * @return {?}
   */
  R.getSubpath = function(name, path, to) {
    if (this.getTotalLength(name) - to < 1E-6) {
      return lookup(name, path).end;
    }
    var val = lookup(name, to, 1);
    return path ? lookup(val, path).end : val;
  };
  /**
   * @return {?}
   */
  self.getTotalLength = function() {
    var suiteView = this.getPath();
    if (suiteView) {
      return this.node.getTotalLength ? this.node.getTotalLength() : isUndefined(suiteView);
    }
  };
  /**
   * @param {?} code
   * @return {?}
   */
  self.getPointAtLength = function(code) {
    var p = this.getPath();
    if (p) {
      return a(p, code);
    }
  };
  /**
   * @return {?}
   */
  self.getPath = function() {
    var num;
    var round = R._getPath[this.type];
    if (this.type != "text" && this.type != "set") {
      return round && (num = round(this)), num;
    }
  };
  /**
   * @param {undefined} from
   * @param {?} to
   * @return {?}
   */
  self.getSubpath = function(from, to) {
    var path = this.getPath();
    if (path) {
      return R.getSubpath(path, from, to);
    }
  };
  options = R.easing_formulas = {
    /**
     * @param {?} t
     * @return {?}
     */
    linear : function(t) {
      return t;
    },
    /**
     * @param {?} x
     * @return {?}
     */
    "<" : function(x) {
      return pow(x, 1.7);
    },
    /**
     * @param {?} x
     * @return {?}
     */
    ">" : function(x) {
      return pow(x, 0.48);
    },
    /**
     * @param {number} dataAndEvents
     * @return {?}
     */
    "<>" : function(dataAndEvents) {
      /** @type {number} */
      var x0 = 0.48 - dataAndEvents / 1.04;
      /** @type {number} */
      var x1 = math.sqrt(0.1734 + x0 * x0);
      /** @type {number} */
      var x = x1 - x0;
      /** @type {number} */
      var inner = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1);
      /** @type {number} */
      var dx = -x1 - x0;
      /** @type {number} */
      var arr = pow(abs(dx), 1 / 3) * (dx < 0 ? -1 : 1);
      /** @type {number} */
      var ratio = inner + arr + 0.5;
      return(1 - ratio) * 3 * ratio * ratio + ratio * ratio * ratio;
    },
    /**
     * @param {number} t
     * @return {?}
     */
    backIn : function(t) {
      /** @type {number} */
      var s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    /**
     * @param {number} time1
     * @return {?}
     */
    backOut : function(time1) {
      /** @type {number} */
      time1 = time1 - 1;
      /** @type {number} */
      var overshoot = 1.70158;
      return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
    },
    /**
     * @param {number} n
     * @return {?}
     */
    elastic : function(n) {
      return n == !!n ? n : pow(2, -10 * n) * math.sin((n - 0.075) * 2 * PI / 0.3) + 1;
    },
    /**
     * @param {number} n
     * @return {?}
     */
    bounce : function(n) {
      /** @type {number} */
      var changeInValue = 7.5625;
      /** @type {number} */
      var p = 2.75;
      var index;
      return n < 1 / p ? index = changeInValue * n * n : n < 2 / p ? (n -= 1.5 / p, index = changeInValue * n * n + 0.75) : n < 2.5 / p ? (n -= 2.25 / p, index = changeInValue * n * n + 0.9375) : (n -= 2.625 / p, index = changeInValue * n * n + 0.984375), index;
    }
  };
  options.easeIn = options["ease-in"] = options["<"];
  options.easeOut = options["ease-out"] = options[">"];
  options.easeInOut = options["ease-in-out"] = options["<>"];
  /** @type {function (number): ?} */
  options["back-in"] = options.backIn;
  /** @type {function (number): ?} */
  options["back-out"] = options.backOut;
  /** @type {Array} */
  var data = [];
  var each = $window.requestAnimationFrame || ($window.webkitRequestAnimationFrame || ($window.mozRequestAnimationFrame || ($window.oRequestAnimationFrame || ($window.msRequestAnimationFrame || function(fn) {
    setTimeout(fn, 16);
  }))));
  /**
   * @return {undefined}
   */
  var check = function() {
    /** @type {number} */
    var timeStamp = +new Date;
    /** @type {number} */
    var idx = 0;
    var self;
    var pos;
    var attr;
    var i;
    var valsLength;
    var j;
    var subLn;
    var splice;
    var prevSources;
    for (;idx < data.length;idx++) {
      if (self = data[idx], !self.el.removed && !self.paused) {
        /** @type {number} */
        var time = timeStamp - self.start;
        var ms = self.ms;
        var floor = self.easing;
        var from = self.from;
        var diff = self.diff;
        var source = self.to;
        var type = self.t;
        var d = self.el;
        var o = {};
        var e;
        var paths = {};
        var prop;
        if (self.initstatus ? (time = (self.initstatus * self.anim.top - self.prev) / (self.percent - self.prev) * ms, self.status = self.initstatus, delete self.initstatus, self.stop && data.splice(idx--, 1)) : self.status = (self.prev + (self.percent - self.prev) * (time / ms)) / self.anim.top, !(time < 0)) {
          if (time < ms) {
            pos = floor(time / ms);
            for (attr in from) {
              if (from[has](attr)) {
                switch(availableAnimAttrs[attr]) {
                  case nu:
                    /** @type {number} */
                    e = +from[attr] + pos * ms * diff[attr];
                    break;
                  case "colour":
                    /** @type {string} */
                    e = "rgb(" + [getArr(round(from[attr].r + pos * ms * diff[attr].r)), getArr(round(from[attr].g + pos * ms * diff[attr].g)), getArr(round(from[attr].b + pos * ms * diff[attr].b))].join(",") + ")";
                    break;
                  case "path":
                    /** @type {Array} */
                    e = [];
                    /** @type {number} */
                    i = 0;
                    valsLength = from[attr].length;
                    for (;i < valsLength;i++) {
                      /** @type {Array} */
                      e[i] = [from[attr][i][0]];
                      /** @type {number} */
                      j = 1;
                      subLn = from[attr][i].length;
                      for (;j < subLn;j++) {
                        /** @type {number} */
                        e[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                      }
                      e[i] = e[i].join(S);
                    }
                    /** @type {string} */
                    e = e.join(S);
                    break;
                  case "transform":
                    if (diff[attr].real) {
                      /** @type {Array} */
                      e = [];
                      /** @type {number} */
                      i = 0;
                      valsLength = from[attr].length;
                      for (;i < valsLength;i++) {
                        /** @type {Array} */
                        e[i] = [from[attr][i][0]];
                        /** @type {number} */
                        j = 1;
                        subLn = from[attr][i].length;
                        for (;j < subLn;j++) {
                          e[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                        }
                      }
                    } else {
                      /**
                       * @param {number} i
                       * @return {?}
                       */
                      splice = function(i) {
                        return+from[attr][i] + pos * ms * diff[attr][i];
                      };
                      /** @type {Array} */
                      e = [["m", splice(0), splice(1), splice(2), splice(3), splice(4), splice(5)]];
                    }
                    break;
                  case "csv":
                    if (attr == "clip-rect") {
                      /** @type {Array} */
                      e = [];
                      /** @type {number} */
                      i = 4;
                      for (;i--;) {
                        /** @type {number} */
                        e[i] = +from[attr][i] + pos * ms * diff[attr][i];
                      }
                    }
                    break;
                  default:
                    prevSources = [][concat](from[attr]);
                    /** @type {Array} */
                    e = [];
                    i = d.paper.customAttributes[attr].length;
                    for (;i--;) {
                      /** @type {number} */
                      e[i] = +prevSources[i] + pos * ms * diff[attr][i];
                    }
                  ;
                }
                /** @type {(Array|number|string|undefined)} */
                o[attr] = e;
              }
            }
            d.attr(o);
            (function(vid, scope, module) {
              setTimeout(function() {
                $("raphael.anim.frame." + vid, scope, module);
              });
            })(d.id, d, self.anim);
          } else {
            if (function(fn, scope, module) {
              setTimeout(function() {
                $("raphael.anim.frame." + scope.id, scope, module);
                $("raphael.anim.finish." + scope.id, scope, module);
                if (R.is(fn, "function")) {
                  fn.call(scope);
                }
              });
            }(self.callback, d, self.anim), d.attr(source), data.splice(idx--, 1), self.repeat > 1 && !self.next) {
              for (prop in source) {
                if (source[has](prop)) {
                  paths[prop] = self.totalOrigin[prop];
                }
              }
              self.el.attr(paths);
              animation(self.anim, self.el, self.anim.percents[0], null, self.totalOrigin, self.repeat - 1);
            }
            if (self.next) {
              if (!self.stop) {
                animation(self.anim, self.el, self.next, null, self.totalOrigin, self.repeat);
              }
            }
          }
        }
      }
    }
    if (R.svg) {
      if (d) {
        if (d.paper) {
          d.paper.safari();
        }
      }
    }
    if (data.length) {
      each(check);
    }
  };
  /**
   * @param {number} i
   * @return {?}
   */
  var getArr = function(i) {
    return i > 255 ? 255 : i < 0 ? 0 : i;
  };
  /**
   * @param {?} el
   * @param {?} keepData
   * @param {HTMLElement} obj
   * @param {number} element
   * @param {string} easing
   * @param {Function} callback
   * @return {?}
   */
  self.animateWith = function(el, keepData, obj, element, easing, callback) {
    var e = this;
    var SELF;
    var i;
    var l;
    if (e.removed) {
      return callback && callback.call(e), e;
    }
    SELF = obj instanceof Node ? obj : R.animation(obj, element, easing, callback);
    animation(SELF, e, SELF.percents[0], null, e.attr());
    /** @type {number} */
    i = 0;
    /** @type {number} */
    l = data.length;
    for (;i < l;i++) {
      if (data[i].anim == keepData && data[i].el == el) {
        data[l - 1].start = data[i].start;
        break;
      }
    }
    return e;
  };
  /**
   * @param {?} name
   * @return {?}
   */
  self.onAnimation = function(name) {
    return name ? $.on("raphael.anim.frame." + this.id, name) : $.unbind("raphael.anim.frame." + this.id), this;
  };
  /**
   * @param {?} wait
   * @return {?}
   */
  Node.prototype.delay = function(wait) {
    var that = new Node(this.anim, this.ms);
    return that.times = this.times, that.del = +wait || 0, that;
  };
  /**
   * @param {?} x
   * @return {?}
   */
  Node.prototype.repeat = function(x) {
    var that = new Node(this.anim, this.ms);
    return that.del = this.del, that.times = math.floor(max(x, 0)) || 1, that;
  };
  /**
   * @param {Object} obj
   * @param {number} id
   * @param {string} easing
   * @param {Function} callback
   * @return {?}
   */
  R.animation = function(obj, id, easing, callback) {
    if (obj instanceof Node) {
      return obj;
    }
    if (R.is(easing, "function") || !easing) {
      callback = callback || (easing || null);
      /** @type {null} */
      easing = null;
    }
    obj = Object(obj);
    /** @type {number} */
    id = +id || 0;
    var o = {};
    var OLD_IE;
    var i;
    for (i in obj) {
      if (obj[has](i)) {
        if (toFloat(i) != i) {
          if (toFloat(i) + "%" != i) {
            /** @type {boolean} */
            OLD_IE = true;
            o[i] = obj[i];
          }
        }
      }
    }
    return OLD_IE ? (easing && (o.easing = easing), callback && (o.callback = callback), new Node({
      100 : o
    }, id)) : new Node(obj, id);
  };
  /**
   * @param {HTMLElement} el
   * @param {number} current
   * @param {string} easing
   * @param {Function} cb
   * @return {?}
   */
  self.animate = function(el, current, easing, cb) {
    var e = this;
    var g;
    return e.removed ? (cb && cb.call(e), e) : (g = el instanceof Node ? el : R.animation(el, current, easing, cb), animation(g, e, g.percents[0], null, e.attr()), e);
  };
  /**
   * @param {boolean} b
   * @param {string} value
   * @return {?}
   */
  self.setTime = function(b, value) {
    return b && (value != null && this.status(b, min(value, b.ms) / b.ms)), this;
  };
  /**
   * @param {boolean} value
   * @param {number} end
   * @return {?}
   */
  self.status = function(value, end) {
    /** @type {Array} */
    var res = [];
    /** @type {number} */
    var _i = 0;
    var _len;
    var e;
    if (end != null) {
      return animation(value, this, -1, min(end, 1)), this;
    }
    /** @type {number} */
    _len = data.length;
    for (;_i < _len;_i++) {
      if (e = data[_i], e.el.id == this.id && (!value || e.anim == value)) {
        if (value) {
          return e.status;
        }
        res.push({
          anim : e.anim,
          status : e.status
        });
      }
    }
    return value ? 0 : res;
  };
  /**
   * @param {boolean} params
   * @return {?}
   */
  self.pause = function(params) {
    /** @type {number} */
    var i = 0;
    for (;i < data.length;i++) {
      if (!(data[i].el.id != this.id)) {
        if (!(params && data[i].anim != params)) {
          if ($("raphael.anim.pause." + this.id, this, data[i].anim) !== false) {
            /** @type {boolean} */
            data[i].paused = true;
          }
        }
      }
    }
    return this;
  };
  /**
   * @param {boolean} params
   * @return {?}
   */
  self.resume = function(params) {
    var p;
    /** @type {number} */
    var i = 0;
    for (;i < data.length;i++) {
      if (!(data[i].el.id != this.id)) {
        if (!(params && data[i].anim != params)) {
          p = data[i];
          if ($("raphael.anim.resume." + this.id, this, p.anim) !== false) {
            delete p.paused;
            this.status(p.anim, p.status);
          }
        }
      }
    }
    return this;
  };
  /**
   * @param {boolean} params
   * @return {?}
   */
  self.stop = function(params) {
    /** @type {number} */
    var i = 0;
    for (;i < data.length;i++) {
      if (!(data[i].el.id != this.id)) {
        if (!(params && data[i].anim != params)) {
          if ($("raphael.anim.stop." + this.id, this, data[i].anim) !== false) {
            data.splice(i--, 1);
          }
        }
      }
    }
    return this;
  };
  $.on("raphael.remove", name);
  $.on("raphael.clear", name);
  /**
   * @return {?}
   */
  self.toString = function() {
    return "Rapha\u00ebl\u2019s object";
  };
  /**
   * @param {Array} items
   * @return {undefined}
   */
  Set = function(items) {
    if (this.items = [], this.length = 0, this.type = "set", items) {
      /** @type {number} */
      var i = 0;
      var valuesLen = items.length;
      for (;i < valuesLen;i++) {
        if (items[i]) {
          if (items[i].constructor == self.constructor || items[i].constructor == Set) {
            this[this.items.length] = this.items[this.items.length] = items[i];
            this.length++;
          }
        }
      }
    }
  };
  setproto = Set.prototype;
  /**
   * @return {?}
   */
  setproto.push = function() {
    var item;
    var len;
    /** @type {number} */
    var i = 0;
    /** @type {number} */
    var argLength = arguments.length;
    for (;i < argLength;i++) {
      item = arguments[i];
      if (item) {
        if (item.constructor == self.constructor || item.constructor == Set) {
          len = this.items.length;
          this[len] = this.items[len] = item;
          this.length++;
        }
      }
    }
    return this;
  };
  /**
   * @return {?}
   */
  setproto.pop = function() {
    return this.length && delete this[this.length--], this.items.pop();
  };
  /**
   * @param {Function} fn
   * @param {?} thisv
   * @return {?}
   */
  setproto.forEach = function(fn, thisv) {
    /** @type {number} */
    var i = 0;
    var len = this.items.length;
    for (;i < len;i++) {
      if (fn.call(thisv, this.items[i], i) === false) {
        return this;
      }
    }
    return this;
  };
  for (method in self) {
    if (self[has](method)) {
      setproto[method] = function(methodname) {
        return function() {
          /** @type {Arguments} */
          var arg = arguments;
          return this.forEach(function(el) {
            el[methodname][apply](el, arg);
          });
        };
      }(method);
    }
  }
  /**
   * @param {string} name
   * @param {(Error|string)} isXML
   * @return {?}
   */
  setproto.attr = function(name, isXML) {
    var a;
    var l;
    var i;
    var numItems;
    if (name && (R.is(name, selector) && R.is(name[0], "object"))) {
      /** @type {number} */
      a = 0;
      l = name.length;
      for (;a < l;a++) {
        this.items[a].attr(name[a]);
      }
    } else {
      /** @type {number} */
      i = 0;
      numItems = this.items.length;
      for (;i < numItems;i++) {
        this.items[i].attr(name, isXML);
      }
    }
    return this;
  };
  /**
   * @return {undefined}
   */
  setproto.clear = function() {
    for (;this.length;) {
      this.pop();
    }
  };
  /**
   * @param {number} start
   * @param {number} recurring
   * @return {?}
   */
  setproto.splice = function(start, recurring) {
    var arglen;
    start = start < 0 ? max(this.length + start, 0) : start;
    /** @type {number} */
    recurring = max(0, min(this.length - start, recurring));
    /** @type {Array} */
    var tail = [];
    /** @type {Array} */
    var todel = [];
    /** @type {Array} */
    var args = [];
    /** @type {number} */
    var i = 2;
    for (;i < arguments.length;i++) {
      args.push(arguments[i]);
    }
    /** @type {number} */
    i = 0;
    for (;i < recurring;i++) {
      todel.push(this[start + i]);
    }
    for (;i < this.length - start;i++) {
      tail.push(this[start + i]);
    }
    /** @type {number} */
    arglen = args.length;
    /** @type {number} */
    i = 0;
    for (;i < arglen + tail.length;i++) {
      this.items[start + i] = this[start + i] = i < arglen ? args[i] : tail[i - arglen];
    }
    /** @type {number} */
    i = this.items.length = this.length -= recurring - arglen;
    for (;this[i];) {
      delete this[i++];
    }
    return new Set(todel);
  };
  /**
   * @param {?} name
   * @return {?}
   */
  setproto.exclude = function(name) {
    /** @type {number} */
    var i = 0;
    var l = this.length;
    for (;i < l;i++) {
      if (this[i] == name) {
        return this.splice(i, 1), true;
      }
    }
  };
  /**
   * @param {Error} el
   * @param {number} idx
   * @param {string} easing
   * @param {Function} callback
   * @return {?}
   */
  setproto.animate = function(el, idx, easing, callback) {
    var key;
    if (R.is(easing, "function") || !easing) {
      callback = easing || null;
    }
    var len = this.items.length;
    var i = len;
    var failuresLink;
    var T = this;
    var cb;
    if (!len) {
      return this;
    }
    if (callback) {
      /**
       * @return {undefined}
       */
      cb = function() {
        if (!--len) {
          callback.call(T);
        }
      };
    }
    easing = R.is(easing, string) ? easing : cb;
    key = R.animation(el, idx, easing, cb);
    failuresLink = this.items[--i].animate(key);
    for (;i--;) {
      if (this.items[i]) {
        if (!this.items[i].removed) {
          this.items[i].animateWith(failuresLink, key, key);
        }
      }
      if (!(this.items[i] && !this.items[i].removed)) {
        len--;
      }
    }
    return this;
  };
  /**
   * @param {Object} input
   * @return {?}
   */
  setproto.insertAfter = function(input) {
    var i = this.items.length;
    for (;i--;) {
      this.items[i].insertAfter(input);
    }
    return this;
  };
  /**
   * @return {?}
   */
  setproto.getBBox = function() {
    var box;
    /** @type {Array} */
    var x = [];
    /** @type {Array} */
    var y = [];
    /** @type {Array} */
    var x2 = [];
    /** @type {Array} */
    var h = [];
    var i = this.items.length;
    for (;i--;) {
      if (!this.items[i].removed) {
        box = this.items[i].getBBox();
        x.push(box.x);
        y.push(box.y);
        x2.push(box.x + box.width);
        h.push(box.y + box.height);
      }
    }
    return x = min[apply](0, x), y = min[apply](0, y), x2 = max[apply](0, x2), h = max[apply](0, h), {
      x : x,
      y : y,
      x2 : x2,
      y2 : h,
      width : x2 - x,
      height : h - y
    };
  };
  /**
   * @param {Array} copy
   * @return {?}
   */
  setproto.clone = function(copy) {
    copy = this.paper.set();
    /** @type {number} */
    var i = 0;
    var len = this.items.length;
    for (;i < len;i++) {
      copy.push(this.items[i].clone());
    }
    return copy;
  };
  /**
   * @return {?}
   */
  setproto.toString = function() {
    return "Rapha\u00ebl\u2018s set";
  };
  /**
   * @param {Object} ctx
   * @return {?}
   */
  setproto.glow = function(ctx) {
    var assigns = this.paper.set();
    return this.forEach(function(filter) {
      var asserterNames = filter.glow(ctx);
      if (asserterNames != null) {
        asserterNames.forEach(function(vvar) {
          assigns.push(vvar);
        });
      }
    }), assigns;
  };
  /**
   * @param {string} x
   * @param {string} y
   * @return {?}
   */
  setproto.isPointInside = function(x, y) {
    /** @type {boolean} */
    var i = false;
    return this.forEach(function(normals) {
      if (normals.isPointInside(x, y)) {
        return i = true, false;
      }
    }), i;
  };
  /**
   * @param {Object} font
   * @return {?}
   */
  R.registerFont = function(font) {
    var fontcopy;
    var family;
    var prop;
    var glyph;
    var path;
    var k;
    if (!font.face) {
      return font;
    }
    this.fonts = this.fonts || {};
    fontcopy = {
      w : font.w,
      face : {},
      glyphs : {}
    };
    family = font.face["font-family"];
    for (prop in font.face) {
      if (font.face[has](prop)) {
        fontcopy.face[prop] = font.face[prop];
      }
    }
    if (this.fonts[family] ? this.fonts[family].push(fontcopy) : this.fonts[family] = [fontcopy], !font.svg) {
      /** @type {number} */
      fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
      for (glyph in font.glyphs) {
        if (font.glyphs[has](glyph) && (path = font.glyphs[glyph], fontcopy.glyphs[glyph] = {
          w : path.w,
          k : {},
          d : path.d && "M" + path.d.replace(/[mlcxtrv]/g, function(command) {
            return{
              l : "L",
              c : "C",
              x : "z",
              t : "m",
              r : "l",
              v : "c"
            }[command] || "M";
          }) + "z"
        }, path.k)) {
          for (k in path.k) {
            if (path[has](k)) {
              fontcopy.glyphs[glyph].k[k] = path.k[k];
            }
          }
        }
      }
    }
    return font;
  };
  /**
   * @param {string} family
   * @param {number} weight
   * @param {string} style
   * @param {string} stretch
   * @return {?}
   */
  paper.getFont = function(family, weight, style, stretch) {
    var codeSegments;
    var rnumnonpx;
    var fontName;
    var thefont;
    var i;
    var valsLength;
    if (stretch = stretch || "normal", style = style || "normal", weight = +weight || ({
      normal : 400,
      bold : 700,
      lighter : 300,
      bolder : 800
    }[weight] || 400), R.fonts) {
      if (codeSegments = R.fonts[family], !codeSegments) {
        /** @type {RegExp} */
        rnumnonpx = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
        for (fontName in R.fonts) {
          if (R.fonts[has](fontName) && rnumnonpx.test(fontName)) {
            codeSegments = R.fonts[fontName];
            break;
          }
        }
      }
      if (codeSegments) {
        /** @type {number} */
        i = 0;
        valsLength = codeSegments.length;
        for (;i < valsLength;i++) {
          if (thefont = codeSegments[i], thefont.face["font-weight"] == weight && ((thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch)) {
            break;
          }
        }
      }
      return thefont;
    }
  };
  /**
   * @param {number} r
   * @param {number} c
   * @param {?} message
   * @param {Object} font
   * @param {number} size
   * @param {string} origin
   * @param {number} s
   * @param {number} depth
   * @return {?}
   */
  paper.print = function(r, c, message, font, size, origin, s, depth) {
    var i;
    var valsLength;
    var prev;
    var a;
    origin = origin || "middle";
    /** @type {number} */
    s = max(min(s || 0, 1), -1);
    /** @type {number} */
    depth = max(min(depth || 1, 3), 1);
    var letters = f(message)[split](E);
    /** @type {number} */
    var x = 0;
    /** @type {number} */
    var labelWidth = 0;
    /** @type {string} */
    var value = E;
    var d;
    if (R.is(font, "string") && (font = this.getFont(font)), font) {
      /** @type {number} */
      d = (size || 16) / font.face["units-per-em"];
      var values = font.face.bbox[split](map);
      /** @type {number} */
      var g = +values[0];
      /** @type {number} */
      var radiusStepSize = values[3] - values[1];
      /** @type {number} */
      var label_width = 0;
      /** @type {number} */
      var b = +values[1] + (origin == "baseline" ? radiusStepSize + +font.face.descent : radiusStepSize / 2);
      /** @type {number} */
      i = 0;
      valsLength = letters.length;
      for (;i < valsLength;i++) {
        if (letters[i] == "\n") {
          /** @type {number} */
          x = 0;
          /** @type {number} */
          a = 0;
          /** @type {number} */
          labelWidth = 0;
          label_width += radiusStepSize * depth;
        } else {
          prev = labelWidth && font.glyphs[letters[i - 1]] || {};
          a = font.glyphs[letters[i]];
          x += labelWidth ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * s : 0;
          /** @type {number} */
          labelWidth = 1;
        }
        if (a) {
          if (a.d) {
            value += R.transformPath(a.d, ["t", x * d, label_width * d, "s", d, d, g, b, "t", (r - g) / d, (c - b) / d]);
          }
        }
      }
    }
    return this.path(value).attr({
      fill : "#000",
      stroke : "none"
    });
  };
  /**
   * @param {?} n
   * @return {?}
   */
  paper.add = function(n) {
    if (R.is(n, "array")) {
      var pointer = this.set();
      /** @type {number} */
      var o = 0;
      var ol = n.length;
      var elem;
      for (;o < ol;o++) {
        elem = n[o] || {};
        if (attr[has](elem.type)) {
          pointer.push(this[elem.type]().attr(elem));
        }
      }
    }
    return pointer;
  };
  /**
   * @param {Object} text
   * @param {number} value
   * @return {?}
   */
  R.format = function(text, value) {
    var second = R.is(value, selector) ? [0][concat](value) : arguments;
    return text && (R.is(text, string) && (second.length - 1 && (text = text.replace(cx, function(dataAndEvents, j) {
      return second[++j] == null ? E : second[j];
    })))), text || E;
  };
  R.fullfill = function() {
    /** @type {RegExp} */
    var r20 = /\{([^\}]+)\}/g;
    /** @type {RegExp} */
    var rreturn = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
    /**
     * @param {string} deepDataAndEvents
     * @param {string} pluginName
     * @param {string} obj
     * @return {?}
     */
    var write = function(deepDataAndEvents, pluginName, obj) {
      /** @type {string} */
      var res = obj;
      return pluginName.replace(rreturn, function(dataAndEvents, type, deepDataAndEvents, fx, ignoreMethodDoesntExist) {
        type = type || fx;
        if (res) {
          if (type in res) {
            res = res[type];
          }
          if (typeof res == "function") {
            if (ignoreMethodDoesntExist) {
              res = res();
            }
          }
        }
      }), res = (res == null || res == obj ? deepDataAndEvents : res) + "";
    };
    return function(html, walkers) {
      return String(html).replace(r20, function(deepDataAndEvents, text) {
        return write(deepDataAndEvents, text, walkers);
      });
    };
  }();
  /**
   * @return {?}
   */
  R.ninja = function() {
    return oldRaphael.was ? win.win.Raphael = oldRaphael.is : delete Raphael, R;
  };
  R.st = setproto;
  (function(doc, orig, fn) {
    /**
     * @return {undefined}
     */
    function next() {
      if (/in/.test(doc.readyState)) {
        setTimeout(next, 9);
      } else {
        R.eve("raphael.DOMload");
      }
    }
    if (doc.readyState == null) {
      if (doc.addEventListener) {
        doc.addEventListener(orig, fn = function() {
          doc.removeEventListener(orig, fn, false);
          /** @type {string} */
          doc.readyState = "complete";
        }, false);
        /** @type {string} */
        doc.readyState = "loading";
      }
    }
    next();
  })(document, "DOMContentLoaded");
  $.on("raphael.DOMload", function() {
    /** @type {boolean} */
    set = true;
  });
  return function() {
    var setproto;
    var method;
    if (R.svg) {
      /** @type {string} */
      var has = "hasOwnProperty";
      /** @type {function (new:String, *=): string} */
      var Str = String;
      /** @type {function (*): number} */
      var toFloat = parseFloat;
      /** @type {function (*, (number|undefined)): number} */
      var toInt = parseInt;
      var math = Math;
      /** @type {function (...[*]): number} */
      var mmax = math.max;
      /** @type {function (*): number} */
      var abs = math.abs;
      /** @type {function (*, *): number} */
      var pow = math.pow;
      /** @type {RegExp} */
      var separator = /[, ]+/;
      var eve = R.eve;
      /** @type {string} */
      var E = "";
      /** @type {string} */
      var x = " ";
      /** @type {string} */
      var xlink = "http://www.w3.org/1999/xlink";
      var markers = {
        block : "M5,0 0,2.5 5,5z",
        classic : "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
        diamond : "M2.5,0 5,2.5 2.5,5 0,2.5z",
        open : "M6,1 1,3.5 6,6",
        oval : "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
      };
      var markerCounter = {};
      /**
       * @return {string}
       */
      R.toString = function() {
        return "Your browser supports SVG.\nYou are running Rapha\u00ebl " + this.version;
      };
      /**
       * @param {string} el
       * @param {?} opt_attributes
       * @return {?}
       */
      var $ = function(el, opt_attributes) {
        var key;
        var value;
        if (opt_attributes) {
          if (typeof el == "string") {
            el = $(el);
          }
          for (key in opt_attributes) {
            if (opt_attributes[has](key)) {
              if (key.substring(0, 6) == "xlink:") {
                el.setAttributeNS(xlink, key.substring(6), Str(opt_attributes[key]));
              } else {
                if (el !== undefined) {
                  /** @type {string} */
                  value = Str(opt_attributes[key]);
                  if (key !== "d" || key === "d" && value !== "M,0,0") {
                    el.setAttribute(key, value);
                  }
                }
              }
            }
          }
        } else {
          el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
          if (el.style) {
            /** @type {string} */
            //el.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
          }
        }
        return el;
      };
      /**
       * @param {Object} element
       * @param {string} gradient
       * @return {?}
       */
      var addGradientFill = function(element, gradient) {
        /** @type {string} */
        var type = "linear";
        var id = element.id + gradient;
        /** @type {number} */
        var fx = 0.5;
        /** @type {number} */
        var fy = 0.5;
        var node = element.node;
        var SVG = element.paper;
        var s = node.style;
        var el = R._g.doc.getElementById(id);
        var angle;
        var vector;
        var max;
        var dots;
        var i;
        var valsLength;
        if (!el) {
          if (gradient = Str(gradient).replace(R._radial_gradient, function(dataAndEvents, _fx, _fy) {
            if (type = "radial", _fx && _fy) {
              /** @type {number} */
              fx = toFloat(_fx);
              /** @type {number} */
              fy = toFloat(_fy);
              /** @type {number} */
              var r = (fy > 0.5) * 2 - 1;
              if (pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25) {
                if (fy = math.sqrt(0.25 - pow(fx - 0.5, 2)) * r + 0.5) {
                  if (fy != 0.5) {
                    /** @type {number} */
                    fy = fy.toFixed(5) - 1E-5 * r;
                  }
                }
              }
            }
            return E;
          }), gradient = gradient.split(/\s*\-\s*/), type == "linear") {
            if (angle = gradient.shift(), angle = -toFloat(angle), isNaN(angle)) {
              return null;
            }
            /** @type {Array} */
            vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))];
            /** @type {number} */
            max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
            vector[2] *= max;
            vector[3] *= max;
            if (vector[2] < 0) {
              /** @type {number} */
              vector[0] = -vector[2];
              /** @type {number} */
              vector[2] = 0;
            }
            if (vector[3] < 0) {
              /** @type {number} */
              vector[1] = -vector[3];
              /** @type {number} */
              vector[3] = 0;
            }
          }
          if (dots = R._parseDots(gradient), !dots) {
            return null;
          }
          if (id = id.replace(/[\(\)\s,\xb0#]/g, "_"), element.gradient && (id != element.gradient.id && (SVG.defs.removeChild(element.gradient), delete element.gradient)), !element.gradient) {
            el = $(type + "Gradient", {
              id : id
            });
            element.gradient = el;
            $(el, type == "radial" ? {
              fx : fx,
              fy : fy
            } : {
              x1 : vector[0],
              y1 : vector[1],
              x2 : vector[2],
              y2 : vector[3],
              gradientTransform : element.matrix.invert()
            });
            SVG.defs.appendChild(el);
            /** @type {number} */
            i = 0;
            valsLength = dots.length;
            for (;i < valsLength;i++) {
              el.appendChild($("stop", {
                offset : dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                "stop-color" : dots[i].color || "#fff"
              }));
            }
          }
        }
        return $(node, {
          fill : "url(#" + id + ")",
          opacity : 1,
          "fill-opacity" : 1
        }), s.fill = E, s.opacity = 1, s.fillOpacity = 1, 1;
      };
      /**
       * @param {Object} o
       * @return {undefined}
       */
      var updatePosition = function(o) {
        var offsetCoordinate = o.getBBox(1);
        $(o.pattern, {
          patternTransform : o.matrix.invert() + " translate(" + offsetCoordinate.x + "," + offsetCoordinate.y + ")"
        });
      };
      /**
       * @param {Object} o
       * @param {?} value
       * @param {boolean} isEnd
       * @return {undefined}
       */
      var addArrow = function(o, value, isEnd) {
        var id;
        var markerId;
        var marker;
        var use;
        var delta;
        var tabPage;
        if (o.type == "path") {
          /** @type {Array.<string>} */
          var values = Str(value).toLowerCase().split("-");
          var p = o.paper;
          /** @type {string} */
          var se = isEnd ? "end" : "start";
          var view = o.node;
          var attrs = o.attrs;
          var stroke = attrs["stroke-width"];
          /** @type {number} */
          var i = values.length;
          /** @type {string} */
          var type = "classic";
          var from;
          var to;
          var dx;
          var refX;
          var attr;
          /** @type {number} */
          var w = 3;
          /** @type {number} */
          var h = 3;
          /** @type {number} */
          var t = 5;
          for (;i--;) {
            switch(values[i]) {
              case "block":
              ;
              case "classic":
              ;
              case "oval":
              ;
              case "diamond":
              ;
              case "open":
              ;
              case "none":
                /** @type {string} */
                type = values[i];
                break;
              case "wide":
                /** @type {number} */
                h = 5;
                break;
              case "narrow":
                /** @type {number} */
                h = 2;
                break;
              case "long":
                /** @type {number} */
                w = 5;
                break;
              case "short":
                /** @type {number} */
                w = 2;
            }
          }
          if (type == "open") {
            w += 2;
            h += 2;
            t += 2;
            /** @type {number} */
            dx = 1;
            /** @type {number} */
            refX = isEnd ? 4 : 1;
            attr = {
              fill : "none",
              stroke : attrs.stroke
            };
          } else {
            /** @type {number} */
            refX = dx = w / 2;
            attr = {
              fill : attrs.stroke,
              stroke : "none"
            };
          }
          if (o._.arrows) {
            if (isEnd) {
              if (o._.arrows.endPath) {
                markerCounter[o._.arrows.endPath]--;
              }
              if (o._.arrows.endMarker) {
                markerCounter[o._.arrows.endMarker]--;
              }
            } else {
              if (o._.arrows.startPath) {
                markerCounter[o._.arrows.startPath]--;
              }
              if (o._.arrows.startMarker) {
                markerCounter[o._.arrows.startMarker]--;
              }
            }
          } else {
            o._.arrows = {};
          }
          if (type != "none") {
            /** @type {string} */
            id = "raphael-marker-" + type;
            /** @type {string} */
            markerId = "raphael-marker-" + se + type + w + h;
            if (R._g.doc.getElementById(id)) {
              markerCounter[id]++;
            } else {
              p.defs.appendChild($($("path"), {
                "stroke-linecap" : "round",
                d : markers[type],
                id : id
              }));
              /** @type {number} */
              markerCounter[id] = 1;
            }
            marker = R._g.doc.getElementById(markerId);
            if (marker) {
              markerCounter[markerId]++;
              use = marker.getElementsByTagName("use")[0];
            } else {
              marker = $($("marker"), {
                id : markerId,
                markerHeight : h,
                markerWidth : w,
                orient : "auto",
                refX : refX,
                refY : h / 2
              });
              use = $($("use"), {
                "xlink:href" : "#" + id,
                transform : (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                "stroke-width" : (2 / (w / t + h / t)).toFixed(4)
              });
              marker.appendChild(use);
              p.defs.appendChild(marker);
              /** @type {number} */
              markerCounter[markerId] = 1;
            }
            $(use, attr);
            /** @type {number} */
            delta = dx * (type != "diamond" && type != "oval");
            if (isEnd) {
              /** @type {number} */
              from = o._.arrows.startdx * stroke || 0;
              /** @type {number} */
              to = R.getTotalLength(attrs.path) - delta * stroke;
            } else {
              /** @type {number} */
              from = delta * stroke;
              /** @type {number} */
              to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
            }
            attr = {};
            /** @type {string} */
            attr["marker-" + se] = "url(#" + markerId + ")";
            if (to || from) {
              attr.d = R.getSubpath(attrs.path, from, to);
            }
            $(view, attr);
            /** @type {string} */
            o._.arrows[se + "Path"] = id;
            /** @type {string} */
            o._.arrows[se + "Marker"] = markerId;
            /** @type {number} */
            o._.arrows[se + "dx"] = delta;
            /** @type {string} */
            o._.arrows[se + "Type"] = type;
            o._.arrows[se + "String"] = value;
          } else {
            if (isEnd) {
              /** @type {number} */
              from = o._.arrows.startdx * stroke || 0;
              /** @type {number} */
              to = R.getTotalLength(attrs.path) - from;
            } else {
              /** @type {number} */
              from = 0;
              /** @type {number} */
              to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
            }
            if (o._.arrows[se + "Path"]) {
              $(view, {
                d : R.getSubpath(attrs.path, from, to)
              });
            }
            delete o._.arrows[se + "Path"];
            delete o._.arrows[se + "Marker"];
            delete o._.arrows[se + "dx"];
            delete o._.arrows[se + "Type"];
            delete o._.arrows[se + "String"];
          }
          for (attr in markerCounter) {
            if (markerCounter[has](attr)) {
              if (!markerCounter[attr]) {
                tabPage = R._g.doc.getElementById(attr);
                if (tabPage) {
                  tabPage.parentNode.removeChild(tabPage);
                }
              }
            }
          }
        }
      };
      var dasharray = {
        "" : [0],
        none : [0],
        "-" : [3, 1],
        "." : [1, 1],
        "-." : [3, 1, 1, 1],
        "-.." : [3, 1, 1, 1, 1, 1],
        ". " : [1, 3],
        "- " : [4, 3],
        "--" : [8, 3],
        "- ." : [4, 3, 1, 3],
        "--." : [8, 3, 1, 3],
        "--.." : [8, 3, 1, 3, 1, 3]
      };
      /**
       * @param {Object} o
       * @param {Arguments} value
       * @param {Object} params
       * @return {undefined}
       */
      var addDashes = function(o, value, params) {
        if (value = dasharray[Str(value).toLowerCase()], value) {
          var width = o.attrs["stroke-width"] || "1";
          var butt = {
            round : width,
            square : width,
            butt : 0
          }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0;
          /** @type {Array} */
          var qs = [];
          var i = value.length;
          for (;i--;) {
            /** @type {number} */
            qs[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
          }
          $(o.node, {
            "stroke-dasharray" : qs.join(",")
          });
        }
      };
      /**
       * @param {Object} o
       * @param {Object} params
       * @return {undefined}
       */
      var setFillAndStroke = function(o, params) {
        var node = o.node;
        var attrs = o.attrs;
        var vis = node.style.visibility;
        var att;
        var value;
        var fragment;
        var c;
        var pn;
        var hl;
        var val;
        var el;
        var rc;
        var block;
        var tabPage;
        var isURL;
        var element;
        var clr;
        var gradient;
        var stops;
        var cssrule;
        /** @type {string} */
        node.style.visibility = "hidden";
        for (att in params) {
          if (params[has](att)) {
            if (!R._availableAttrs[has](att)) {
              continue;
            }
            value = params[att];
            attrs[att] = value;
            switch(att) {
              case "blur":
                o.blur(value);
                break;
              case "title":
                fragment = node.getElementsByTagName("title");
                if (fragment.length && (fragment = fragment[0])) {
                  fragment.firstChild.nodeValue = value;
                } else {
                  fragment = $("title");
                  c = R._g.doc.createTextNode(value);
                  fragment.appendChild(c);
                  node.appendChild(fragment);
                }
                break;
              case "href":
              ;
              case "target":
                pn = node.parentNode;
                if (pn.tagName.toLowerCase() != "a") {
                  hl = $("a");
                  pn.insertBefore(hl, node);
                  hl.appendChild(node);
                  pn = hl;
                }
                if (att == "target") {
                  pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                } else {
                  pn.setAttributeNS(xlink, att, value);
                }
                break;
              case "cursor":
                node.style.cursor = value;
                break;
              case "transform":
                o.transform(value);
                break;
              case "arrow-start":
                addArrow(o, value);
                break;
              case "arrow-end":
                addArrow(o, value, 1);
                break;
              case "clip-rect":
                /** @type {Array.<string>} */
                val = Str(value).split(separator);
                if (val.length == 4) {
                  if (o.clip) {
                    o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                  }
                  el = $("clipPath");
                  rc = $("rect");
                  el.id = R.createUUID();
                  $(rc, {
                    x : val[0],
                    y : val[1],
                    width : val[2],
                    height : val[3]
                  });
                  el.appendChild(rc);
                  o.paper.defs.appendChild(el);
                  $(node, {
                    "clip-path" : "url(#" + el.id + ")"
                  });
                  o.clip = rc;
                }
                if (!value) {
                  block = node.getAttribute("clip-path");
                  if (block) {
                    tabPage = R._g.doc.getElementById(block.replace(/(^url\(#|\)$)/g, E));
                    if (tabPage) {
                      tabPage.parentNode.removeChild(tabPage);
                    }
                    $(node, {
                      "clip-path" : E
                    });
                    delete o.clip;
                  }
                }
                break;
              case "path":
                if (o.type == "path") {
                  $(node, {
                    d : value ? attrs.path = R._pathToAbsolute(value) : "M0,0"
                  });
                  /** @type {number} */
                  o._.dirty = 1;
                  if (o._.arrows) {
                    if ("startString" in o._.arrows) {
                      addArrow(o, o._.arrows.startString);
                    }
                    if ("endString" in o._.arrows) {
                      addArrow(o, o._.arrows.endString, 1);
                    }
                  }
                }
                break;
              case "width":
                if (node.setAttribute(att, value), o._.dirty = 1, attrs.fx) {
                  /** @type {string} */
                  att = "x";
                  value = attrs.x;
                } else {
                  break;
                }
              ;
              case "x":
                if (attrs.fx) {
                  /** @type {number} */
                  value = -attrs.x - (attrs.width || 0);
                }
              ;
              case "rx":
                if (att == "rx" && o.type == "rect") {
                  break;
                }
              ;
              case "cx":
                node.setAttribute(att, value);
                if (o.pattern) {
                  updatePosition(o);
                }
                /** @type {number} */
                o._.dirty = 1;
                break;
              case "height":
                if (node.setAttribute(att, value), o._.dirty = 1, attrs.fy) {
                  /** @type {string} */
                  att = "y";
                  value = attrs.y;
                } else {
                  break;
                }
              ;
              case "y":
                if (attrs.fy) {
                  /** @type {number} */
                  value = -attrs.y - (attrs.height || 0);
                }
              ;
              case "ry":
                if (att == "ry" && o.type == "rect") {
                  break;
                }
              ;
              case "cy":
                node.setAttribute(att, value);
                if (o.pattern) {
                  updatePosition(o);
                }
                /** @type {number} */
                o._.dirty = 1;
                break;
              case "r":
                if (o.type == "rect") {
                  $(node, {
                    rx : value,
                    ry : value
                  });
                } else {
                  node.setAttribute(att, value);
                }
                /** @type {number} */
                o._.dirty = 1;
                break;
              case "src":
                if (o.type == "image") {
                  node.setAttributeNS(xlink, "href", value);
                }
                break;
              case "stroke-width":
                if (o._.sx != 1 || o._.sy != 1) {
                  value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                }
                if (o.paper._vbSize) {
                  value *= o.paper._vbSize;
                }
                node.setAttribute(att, value);
                if (attrs["stroke-dasharray"]) {
                  addDashes(o, attrs["stroke-dasharray"], params);
                }
                if (o._.arrows) {
                  if ("startString" in o._.arrows) {
                    addArrow(o, o._.arrows.startString);
                  }
                  if ("endString" in o._.arrows) {
                    addArrow(o, o._.arrows.endString, 1);
                  }
                }
                break;
              case "stroke-dasharray":
                addDashes(o, value, params);
                break;
              case "fill":
                if (isURL = Str(value).match(R._ISURL), isURL) {
                  el = $("pattern");
                  element = $("image");
                  el.id = R.createUUID();
                  $(el, {
                    x : 0,
                    y : 0,
                    patternUnits : "userSpaceOnUse",
                    height : 1,
                    width : 1
                  });
                  $(element, {
                    x : 0,
                    y : 0,
                    "xlink:href" : isURL[1]
                  });
                  el.appendChild(element);
                  (function(el) {
                    R._preload(isURL[1], function() {
                      var w = this.offsetWidth;
                      var h = this.offsetHeight;
                      $(el, {
                        width : w,
                        height : h
                      });
                      $(element, {
                        width : w,
                        height : h
                      });
                      o.paper.safari();
                    });
                  })(el);
                  o.paper.defs.appendChild(el);
                  $(node, {
                    fill : "url(#" + el.id + ")"
                  });
                  o.pattern = el;
                  if (o.pattern) {
                    updatePosition(o);
                  }
                  break;
                }
                if (clr = R.getRGB(value), clr.error) {
                  if ((o.type == "circle" || (o.type == "ellipse" || Str(value).charAt() != "r")) && addGradientFill(o, value)) {
                    if ("opacity" in attrs || "fill-opacity" in attrs) {
                      gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                      if (gradient) {
                        stops = gradient.getElementsByTagName("stop");
                        $(stops[stops.length - 1], {
                          "stop-opacity" : ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                        });
                      }
                    }
                    attrs.gradient = value;
                    /** @type {string} */
                    attrs.fill = "none";
                    break;
                  }
                } else {
                  delete params.gradient;
                  delete attrs.gradient;
                  if (!R.is(attrs.opacity, "undefined")) {
                    if (R.is(params.opacity, "undefined")) {
                      $(node, {
                        opacity : attrs.opacity
                      });
                    }
                  }
                  if (!R.is(attrs["fill-opacity"], "undefined")) {
                    if (R.is(params["fill-opacity"], "undefined")) {
                      $(node, {
                        "fill-opacity" : attrs["fill-opacity"]
                      });
                    }
                  }
                }
                if (clr[has]("opacity")) {
                  $(node, {
                    "fill-opacity" : clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                  });
                }
              ;
              case "stroke":
                clr = R.getRGB(value);
                node.setAttribute(att, clr.hex);
                if (att == "stroke") {
                  if (clr[has]("opacity")) {
                    $(node, {
                      "stroke-opacity" : clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                  }
                }
                if (att == "stroke") {
                  if (o._.arrows) {
                    if ("startString" in o._.arrows) {
                      addArrow(o, o._.arrows.startString);
                    }
                    if ("endString" in o._.arrows) {
                      addArrow(o, o._.arrows.endString, 1);
                    }
                  }
                }
                break;
              case "gradient":
                if (o.type == "circle" || (o.type == "ellipse" || Str(value).charAt() != "r")) {
                  addGradientFill(o, value);
                }
                break;
              case "opacity":
                if (attrs.gradient) {
                  if (!attrs[has]("stroke-opacity")) {
                    $(node, {
                      "stroke-opacity" : value > 1 ? value / 100 : value
                    });
                  }
                }
              ;
              case "fill-opacity":
                if (attrs.gradient) {
                  gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                  if (gradient) {
                    stops = gradient.getElementsByTagName("stop");
                    $(stops[stops.length - 1], {
                      "stop-opacity" : value
                    });
                  }
                  break;
                }
              ;
              default:
                if (att == "font-size") {
                  /** @type {string} */
                  value = toInt(value, 10) + "px";
                }
                /** @type {string} */
                cssrule = att.replace(/(\-.)/g, function(charsetPart) {
                  return charsetPart.substring(1).toUpperCase();
                });
                node.style[cssrule] = value;
                /** @type {number} */
                o._.dirty = 1;
                node.setAttribute(att, value);
            }
          }
        }
        tuneText(o, params);
        node.style.visibility = vis;
      };
      /** @type {number} */
      var leading = 1.2;
      /**
       * @param {Object} el
       * @param {Object} params
       * @return {undefined}
       */
      var tuneText = function(el, params) {
        var configList;
        var tspans;
        var tspan;
        var i;
        var ln;
        var winSize;
        var b;
        if (el.type == "text" && (params[has]("text") || (params[has]("font") || (params[has]("font-size") || (params[has]("x") || params[has]("y")))))) {
          var a = el.attrs;
          var node = el.node;
          /** @type {number} */
          var fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;
          if (params[has]("text")) {
            a.text = params.text;
            for (;node.firstChild;) {
              node.removeChild(node.firstChild);
            }
            /** @type {Array.<string>} */
            configList = Str(params.text).split("\n");
            /** @type {Array} */
            tspans = [];
            /** @type {number} */
            i = 0;
            /** @type {number} */
            ln = configList.length;
            for (;i < ln;i++) {
              tspan = $("tspan");
              if (i) {
                $(tspan, {
                  dy : fontSize * leading,
                  x : a.x
                });
              }
              tspan.appendChild(R._g.doc.createTextNode(configList[i]));
              node.appendChild(tspan);
              tspans[i] = tspan;
            }
          } else {
            tspans = node.getElementsByTagName("tspan");
            /** @type {number} */
            i = 0;
            ln = tspans.length;
            for (;i < ln;i++) {
              if (i) {
                $(tspans[i], {
                  dy : fontSize * leading,
                  x : a.x
                });
              } else {
                $(tspans[0], {
                  dy : 0
                });
              }
            }
          }
          $(node, {
            x : a.x,
            y : a.y
          });
          /** @type {number} */
          el._.dirty = 1;
          winSize = el._getBBox();
          /** @type {number} */
          b = a.y - (winSize.y + winSize.height / 2);
          if (b) {
            if (R.is(b, "finite")) {
              $(tspans[0], {
                dy : b
              });
            }
          }
        }
      };
      /**
       * @param {Object} node
       * @param {?} vml
       * @return {undefined}
       */
      var Element = function(node, vml) {
        this[0] = this.node = node;
        /** @type {boolean} */
        node.raphael = true;
        /** @type {number} */
        this.id = R._oid++;
        /** @type {number} */
        node.raphaelid = this.id;
        this.matrix = R.matrix();
        /** @type {null} */
        this.realPath = null;
        this.paper = vml;
        this.attrs = this.attrs || {};
        this._ = {
          transform : [],
          sx : 1,
          sy : 1,
          deg : 0,
          dx : 0,
          dy : 0,
          dirty : 1
        };
        if (!vml.bottom) {
          vml.bottom = this;
        }
        this.prev = vml.top;
        if (vml.top) {
          vml.top.next = this;
        }
        vml.top = this;
        /** @type {null} */
        this.next = null;
      };
      var elproto = R.el;
      Element.prototype = elproto;
      /** @type {function (Object, ?): undefined} */
      elproto.constructor = Element;
      /**
       * @param {string} value
       * @param {Function} target
       * @return {?}
       */
      R._engine.path = function(value, target) {
        var el = $("path");
        var p;
        return target.canvas && target.canvas.appendChild(el), p = new Element(el, target), p.type = "path", setFillAndStroke(p, {
          fill : "none",
          stroke : "#000",
          path : value
        }), p;
      };
      /**
       * @param {number} deg
       * @param {number} cx
       * @param {number} cy
       * @return {?}
       */
      elproto.rotate = function(deg, cx, cy) {
        if (this.removed) {
          return this;
        }
        if (deg = Str(deg).split(separator), deg.length - 1 && (cx = toFloat(deg[1]), cy = toFloat(deg[2])), deg = toFloat(deg[0]), cy == null && (cx = cy), cx == null || cy == null) {
          var bbox = this.getBBox(1);
          cx = bbox.x + bbox.width / 2;
          cy = bbox.y + bbox.height / 2;
        }
        return this.transform(this._.transform.concat([["r", deg, cx, cy]])), this;
      };
      /**
       * @param {(number|string)} sx
       * @param {(number|string)} sy
       * @param {string} cx
       * @param {string} cy
       * @return {?}
       */
      elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) {
          return this;
        }
        if (sx = Str(sx).split(separator), sx.length - 1 && (sy = toFloat(sx[1]), cx = toFloat(sx[2]), cy = toFloat(sx[3])), sx = toFloat(sx[0]), sy == null && (sy = sx), cy == null && (cx = cy), cx == null || cy == null) {
          var bbox = this.getBBox(1)
        }
        return cx = cx == null ? bbox.x + bbox.width / 2 : cx, cy = cy == null ? bbox.y + bbox.height / 2 : cy, this.transform(this._.transform.concat([["s", sx, sy, cx, cy]])), this;
      };
      /**
       * @param {number} dx
       * @param {(number|string)} dataAndEvents
       * @return {?}
       */
      elproto.translate = function(dx, dataAndEvents) {
        return this.removed ? this : (dx = Str(dx).split(separator), dx.length - 1 && (dataAndEvents = toFloat(dx[1])), dx = toFloat(dx[0]) || 0, dataAndEvents = +dataAndEvents || 0, this.transform(this._.transform.concat([["t", dx, dataAndEvents]])), this);
      };
      /**
       * @param {string} value
       * @return {?}
       */
      elproto.transform = function(value) {
        var _ = this._;
        var sw;
        return value == null ? _.transform : (R._extractTransform(this, value), this.clip && $(this.clip, {
          transform : this.matrix.invert()
        }), this.pattern && updatePosition(this), this.node && $(this.node, {
          transform : this.matrix
        }), (_.sx != 1 || _.sy != 1) && (sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1, this.attr({
          "stroke-width" : sw
        })), this);
      };
      /**
       * @return {?}
       */
      elproto.hide = function() {
        return this.removed || this.paper.safari(this.node.style.display = "none"), this;
      };
      /**
       * @return {?}
       */
      elproto.show = function() {
        return this.removed || this.paper.safari(this.node.style.display = ""), this;
      };
      /**
       * @return {undefined}
       */
      elproto.remove = function() {
        var paper;
        var i;
        if (!this.removed && this.node.parentNode) {
          paper = this.paper;
          if (paper.__set__) {
            paper.__set__.exclude(this);
          }
          eve.unbind("raphael.*.*." + this.id);
          if (this.gradient) {
            paper.defs.removeChild(this.gradient);
          }
          R._tear(this, paper);
          if (this.node.parentNode.tagName.toLowerCase() == "a") {
            this.node.parentNode.parentNode.removeChild(this.node.parentNode);
          } else {
            this.node.parentNode.removeChild(this.node);
          }
          for (i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
          }
          /** @type {boolean} */
          this.removed = true;
        }
      };
      /**
       * @return {?}
       */
      elproto._getBBox = function() {
        var hide;
        var thisp;
        if (this.node.style.display == "none") {
          this.show();
          /** @type {boolean} */
          hide = true;
        }
        thisp = {};
        try {
          thisp = this.node.getBBox();
        } catch (i) {
        } finally {
          thisp = thisp || {};
        }
        return hide && this.hide(), thisp;
      };
      /**
       * @param {string} name
       * @param {?} value
       * @return {?}
       */
      elproto.attr = function(name, value) {
        var res;
        var a;
        var names;
        var out;
        var i;
        var ii;
        var params;
        var key;
        var par;
        var subkey;
        if (this.removed) {
          return this;
        }
        if (name == null) {
          res = {};
          for (a in this.attrs) {
            if (this.attrs[has](a)) {
              res[a] = this.attrs[a];
            }
          }
          return res.gradient && (res.fill == "none" && ((res.fill = res.gradient) && delete res.gradient)), res.transform = this._.transform, res;
        }
        if (value == null && R.is(name, "string")) {
          if (name == "fill" && (this.attrs.fill == "none" && this.attrs.gradient)) {
            return this.attrs.gradient;
          }
          if (name == "transform") {
            return this._.transform;
          }
          names = name.split(separator);
          out = {};
          /** @type {number} */
          i = 0;
          ii = names.length;
          for (;i < ii;i++) {
            name = names[i];
            out[name] = name in this.attrs ? this.attrs[name] : R.is(this.paper.customAttributes[name], "function") ? this.paper.customAttributes[name].def : R._availableAttrs[name];
          }
          return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
          out = {};
          /** @type {number} */
          i = 0;
          ii = name.length;
          for (;i < ii;i++) {
            out[name[i]] = this.attr(name[i]);
          }
          return out;
        }
        if (value != null) {
          params = {};
          params[name] = value;
        } else {
          if (name != null) {
            if (R.is(name, "object")) {
              /** @type {string} */
              params = name;
            }
          }
        }
        for (key in params) {
          eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) {
          if (this.paper.customAttributes[has](key) && (params[has](key) && R.is(this.paper.customAttributes[key], "function"))) {
            par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (subkey in par) {
              if (par[has](subkey)) {
                params[subkey] = par[subkey];
              }
            }
          }
        }
        return setFillAndStroke(this, params), this;
      };
      /**
       * @return {?}
       */
      elproto.toFront = function() {
        if (this.removed) {
          return this;
        }
        if (this.node.parentNode.tagName.toLowerCase() == "a") {
          this.node.parentNode.parentNode.appendChild(this.node.parentNode);
        } else {
          this.node.parentNode.appendChild(this.node);
        }
        var svg = this.paper;
        return svg.top != this && R._tofront(this, svg), this;
      };
      /**
       * @return {?}
       */
      elproto.toBack = function() {
        var parent;
        var paper;
        return this.removed ? this : (parent = this.node.parentNode, parent === null) ? this : (parent.tagName.toLowerCase() == "a" ? parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild) : parent.firstChild != this.node && parent.insertBefore(this.node, this.node.parentNode.firstChild), R._toback(this, this.paper), paper = this.paper, this);
      };
      /**
       * @param {Array} element
       * @return {?}
       */
      elproto.insertAfter = function(element) {
        if (this.removed) {
          return this;
        }
        var el = element.node || element[element.length - 1].node;
        return el.nextSibling ? el.parentNode.insertBefore(this.node, el.nextSibling) : el.parentNode.appendChild(this.node), R._insertafter(this, element, this.paper), this;
      };
      /**
       * @param {Object} element
       * @return {?}
       */
      elproto.insertBefore = function(element) {
        if (this.removed) {
          return this;
        }
        var insertAt = element.node || element[0].node;
        return insertAt.parentNode.insertBefore(this.node, insertAt), R._insertbefore(this, element, this.paper), this;
      };
      /**
       * @param {string} value
       * @return {?}
       */
      elproto.blur = function(value) {
        var t = this;
        var fltr;
        var blur;
        return+value != 0 ? (fltr = $("filter"), blur = $("feGaussianBlur"), t.attrs.blur = value, fltr.id = R.createUUID(), $(blur, {
          stdDeviation : +value || 1.5
        }), fltr.appendChild(blur), t.paper.defs.appendChild(fltr), t._blur = fltr, $(t.node, {
          filter : "url(#" + fltr.id + ")"
        })) : (t._blur && (t._blur.parentNode.removeChild(t._blur), delete t._blur, delete t.attrs.blur), t.node.removeAttribute("filter")), t;
      };
      /**
       * @param {Object} svg
       * @param {number} x
       * @param {number} y
       * @param {number} r
       * @return {?}
       */
      R._engine.circle = function(svg, x, y, r) {
        var el = $("circle");
        var res;
        return svg.canvas && svg.canvas.appendChild(el), res = new Element(el, svg), res.attrs = {
          cx : x,
          cy : y,
          r : r,
          fill : "none",
          stroke : "#000"
        }, res.type = "circle", $(el, res.attrs), res;
      };
      /**
       * @param {Object} parent
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       * @param {number} r
       * @return {?}
       */
      R._engine.rect = function(parent, x, y, w, h, r) {
        var el = $("rect");
        var res;
        return parent.canvas && parent.canvas.appendChild(el), res = new Element(el, parent), res.attrs = {
          x : x,
          y : y,
          width : w,
          height : h,
          r : r || 0,
          rx : r || 0,
          ry : r || 0,
          fill : "none",
          stroke : "#000"
        }, res.type = "rect", $(el, res.attrs), res;
      };
      /**
       * @param {Object} svg
       * @param {number} x
       * @param {number} y
       * @param {number} rx
       * @param {number} ry
       * @return {?}
       */
      R._engine.ellipse = function(svg, x, y, rx, ry) {
        var el = $("ellipse");
        var res;
        return svg.canvas && svg.canvas.appendChild(el), res = new Element(el, svg), res.attrs = {
          cx : x,
          cy : y,
          rx : rx,
          ry : ry,
          fill : "none",
          stroke : "#000"
        }, res.type = "ellipse", $(el, res.attrs), res;
      };
      /**
       * @param {Object} svg
       * @param {string} src
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       * @return {?}
       */
      R._engine.image = function(svg, src, x, y, w, h) {
        var el = $("image");
        var res;
        return $(el, {
          x : x,
          y : y,
          width : w,
          height : h,
          preserveAspectRatio : "none"
        }), el.setAttributeNS(xlink, "href", src), svg.canvas && svg.canvas.appendChild(el), res = new Element(el, svg), res.attrs = {
          x : x,
          y : y,
          width : w,
          height : h,
          src : src
        }, res.type = "image", res;
      };
      /**
       * @param {string} value
       * @param {Function} target
       * @param {number} y
       * @param {string} item
       * @return {?}
       */
      R._engine.text = function(value, target, y, item) {
        var w = $("text");
        var res;
        return value.canvas && value.canvas.appendChild(w), res = new Element(w, value), res.attrs = {
          /** @type {Function} */
          x : target,
          y : y,
          "text-anchor" : "middle",
          text : item,
          font : R._availableAttrs.font,
          stroke : "none",
          fill : "#000"
        }, res.type = "text", setFillAndStroke(res, res.attrs), res;
      };
      /**
       * @param {(number|string)} width
       * @param {(number|string)} height
       * @return {?}
       */
      R._engine.setSize = function(width, height) {
        return this.width = width || this.width, this.height = height || this.height, this.canvas.setAttribute("width", this.width), this.canvas.setAttribute("height", this.height), this._viewBox && this.setViewBox.apply(this, this._viewBox), this;
      };
      /**
       * @return {?}
       */
      R._engine.create = function() {
        var con = R._getContainer.apply(0, arguments);
        var container = con && con.container;
        var left = con.x;
        var y = con.y;
        var width = con.width;
        var height = con.height;
        var element;
        var unselect;
        var c;
        if (!container) {
          throw new Error("SVG container not found.");
        }
        return element = $("svg"), unselect = "overflow:hidden;", left = left || 0, y = y || 0, width = width || 512, height = height || 342, $(element, {
          height : height,
          version : 1.1,
          width : width,
          xmlns : "http://www.w3.org/2000/svg"
        }), container == 1 ? (element.style.cssText = unselect + "position:absolute;left:" + left + "px;top:" + y + "px", R._g.doc.body.appendChild(element), c = 1) : (element.style.cssText = unselect + "position:relative", container.firstChild ? container.insertBefore(element, container.firstChild) : container.appendChild(element)), container = new R._Paper, container.width = width, container.height = height, container.canvas = element, container.clear(), container._left = container._top = 0, c && 
        (container.renderfix = function() {
        }), container.renderfix(), container;
      };
      /**
       * @param {string} w
       * @param {string} y
       * @param {number} width
       * @param {number} h
       * @param {boolean} fit
       * @return {?}
       */
      R._engine.setViewBox = function(w, y, width, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [w, y, width, h, fit]);
        /** @type {number} */
        var size = mmax(width / this.width, h / this.height);
        var top = this.top;
        /** @type {string} */
        var aspectRatio = fit ? "xMidYMid meet" : "xMinYMin";
        var vb;
        var sw;
        if (w == null) {
          if (this._vbSize) {
            /** @type {number} */
            size = 1;
          }
          delete this._vbSize;
          /** @type {string} */
          vb = "0 0 " + this.width + x + this.height;
        } else {
          /** @type {number} */
          this._vbSize = size;
          /** @type {string} */
          vb = w + x + y + x + width + x + h;
        }
        $(this.canvas, {
          viewBox : vb,
          preserveAspectRatio : aspectRatio
        });
        for (;size && top;) {
          sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
          top.attr({
            "stroke-width" : sw
          });
          /** @type {number} */
          top._.dirty = 1;
          /** @type {number} */
          top._.dirtyT = 1;
          top = top.prev;
        }
        return this._viewBox = [w, y, width, h, !!fit], this;
      };
      /**
       * @return {undefined}
       */
      R.prototype.renderfix = function() {
        var cnvs = this.canvas;
        var s = cnvs.style;
        var argv;
        var left;
        var top;
        try {
          argv = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (f) {
          argv = cnvs.createSVGMatrix();
        }
        /** @type {number} */
        left = -argv.e % 1;
        /** @type {number} */
        top = -argv.f % 1;
        if (left || top) {
          if (left) {
            /** @type {number} */
            this._left = (this._left + left) % 1;
            /** @type {string} */
            s.left = this._left + "px";
          }
          if (top) {
            /** @type {number} */
            this._top = (this._top + top) % 1;
            /** @type {string} */
            s.top = this._top + "px";
          }
        }
      };
      /**
       * @return {undefined}
       */
      R.prototype.clear = function() {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        for (;c.firstChild;) {
          c.removeChild(c.firstChild);
        }
        /** @type {null} */
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\u00ebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
      };
      /**
       * @return {undefined}
       */
      R.prototype.remove = function() {
        eve("raphael.remove", this);
        if (this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
        var i;
        for (i in this) {
          this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
      };
      setproto = R.st;
      for (method in elproto) {
        if (elproto[has](method)) {
          if (!setproto[has](method)) {
            setproto[method] = function(methodName) {
              return function() {
                /** @type {Arguments} */
                var args = arguments;
                return this.forEach(function(wrapped) {
                  wrapped[methodName].apply(wrapped, args);
                });
              };
            }(method);
          }
        }
      }
    }
  }(), function() {
    var createNode;
    var setproto;
    var method;
    if (R.vml) {
      /** @type {string} */
      var has = "hasOwnProperty";
      /** @type {function (new:String, *=): string} */
      var Str = String;
      /** @type {function (*): number} */
      var toFloat = parseFloat;
      var math = Math;
      /** @type {function (*): number} */
      var round = math.round;
      /** @type {function (...[*]): number} */
      var mmax = math.max;
      /** @type {function (...[*]): number} */
      var mmin = math.min;
      /** @type {function (*): number} */
      var abs = math.abs;
      /** @type {string} */
      var fillString = "fill";
      /** @type {RegExp} */
      var separator = /[, ]+/;
      var eve = R.eve;
      /** @type {string} */
      var ms = " progid:DXImageTransform.Microsoft";
      /** @type {string} */
      var S = " ";
      /** @type {string} */
      var E = "";
      var map = {
        M : "m",
        L : "l",
        C : "c",
        Z : "x",
        m : "t",
        l : "r",
        c : "v",
        z : "x"
      };
      /** @type {RegExp} */
      var rreturn = /([clmz]),?([^clmz]*)/gi;
      /** @type {RegExp} */
      var r20 = / progid:\S+Blur\([^\)]+\)/g;
      /** @type {RegExp} */
      var rSlash = /-?[^,\s-]+/g;
      /** @type {string} */
      var stylesString = "position:absolute;left:0;top:0;width:1px;height:1px";
      /** @type {number} */
      var zoom = 21600;
      var pathTypes = {
        path : 1,
        rect : 1,
        image : 1
      };
      var ovalTypes = {
        circle : 1,
        ellipse : 1
      };
      /**
       * @param {Object} path
       * @return {?}
       */
      var path2vml = function(path) {
        /** @type {RegExp} */
        var total = /[ahqstv]/ig;
        /** @type {function (Object): ?} */
        var command = R._pathToAbsolute;
        var results;
        var pa;
        var p;
        var r;
        var i;
        var valsLength;
        var j;
        var jj;
        if (Str(path).match(total) && (command = R._path2curve), total = /[clmz]/g, command == R._pathToAbsolute && !Str(path).match(total)) {
          return Str(path).replace(rreturn, function(dataAndEvents, command, s) {
            /** @type {Array} */
            var vals = [];
            /** @type {boolean} */
            var isMove = command.toLowerCase() == "m";
            var res = map[command];
            return s.replace(rSlash, function(value) {
              if (isMove) {
                if (vals.length == 2) {
                  res += vals + map[command == "m" ? "l" : "L"];
                  /** @type {Array} */
                  vals = [];
                }
              }
              vals.push(round(value * zoom));
            }), res + vals;
          });
        }
        pa = command(path);
        /** @type {Array} */
        results = [];
        /** @type {number} */
        i = 0;
        valsLength = pa.length;
        for (;i < valsLength;i++) {
          p = pa[i];
          r = pa[i][0].toLowerCase();
          if (r == "z") {
            /** @type {string} */
            r = "x";
          }
          /** @type {number} */
          j = 1;
          jj = p.length;
          for (;j < jj;j++) {
            r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
          }
          results.push(r);
        }
        return results.join(S);
      };
      /**
       * @param {number} deg
       * @param {string} value
       * @param {?} name
       * @return {?}
       */
      var compensation = function(deg, value, name) {
        var d = R.matrix();
        return d.rotate(-deg, 0.5, 0.5), {
          dx : d.x(value, name),
          dy : d.y(value, name)
        };
      };
      /**
       * @param {Object} p
       * @param {number} sx
       * @param {number} sy
       * @param {number} dx
       * @param {number} dy
       * @param {number} deg
       * @return {undefined}
       */
      var setCoords = function(p, sx, sy, dx, dy, deg) {
        var _ = p._;
        var m = p.matrix;
        var fillpos = _.fillpos;
        var o = p.node;
        var s = o.style;
        /** @type {number} */
        var y = 1;
        /** @type {string} */
        var flip = "";
        /** @type {number} */
        var kx = zoom / sx;
        /** @type {number} */
        var ky = zoom / sy;
        var c;
        var fill;
        if (s.visibility = "hidden", sx && sy) {
          /** @type {string} */
          o.coordsize = abs(kx) + S + abs(ky);
          /** @type {number} */
          s.rotation = deg * (sx * sy < 0 ? -1 : 1);
          if (deg) {
            c = compensation(deg, dx, dy);
            dx = c.dx;
            dy = c.dy;
          }
          if (sx < 0) {
            flip += "x";
          }
          if (sy < 0) {
            if (flip += " y") {
              /** @type {number} */
              y = -1;
            }
          }
          /** @type {string} */
          s.flip = flip;
          /** @type {string} */
          o.coordorigin = dx * -kx + S + dy * -ky;
          if (fillpos || _.fillsize) {
            fill = o.getElementsByTagName(fillString);
            fill = fill && fill[0];
            o.removeChild(fill);
            if (fillpos) {
              c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
              /** @type {string} */
              fill.position = c.dx * y + S + c.dy * y;
            }
            if (_.fillsize) {
              /** @type {string} */
              fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
            }
            o.appendChild(fill);
          }
          /** @type {string} */
          s.visibility = "visible";
        }
      };
      /**
       * @return {string}
       */
      R.toString = function() {
        return "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\u00ebl " + this.version;
      };
      /**
       * @param {Object} o
       * @param {?} value
       * @param {boolean} isEnd
       * @return {undefined}
       */
      var addArrow = function(o, value, isEnd) {
        /** @type {Array.<string>} */
        var values = Str(value).toLowerCase().split("-");
        /** @type {string} */
        var se = isEnd ? "end" : "start";
        /** @type {number} */
        var i = values.length;
        /** @type {string} */
        var type = "classic";
        /** @type {string} */
        var w = "medium";
        /** @type {string} */
        var h = "medium";
        var stroke;
        for (;i--;) {
          switch(values[i]) {
            case "block":
            ;
            case "classic":
            ;
            case "oval":
            ;
            case "diamond":
            ;
            case "open":
            ;
            case "none":
              /** @type {string} */
              type = values[i];
              break;
            case "wide":
            ;
            case "narrow":
              /** @type {string} */
              h = values[i];
              break;
            case "long":
            ;
            case "short":
              /** @type {string} */
              w = values[i];
          }
        }
        stroke = o.node.getElementsByTagName("stroke")[0];
        /** @type {string} */
        stroke[se + "arrow"] = type;
        /** @type {string} */
        stroke[se + "arrowlength"] = w;
        /** @type {string} */
        stroke[se + "arrowwidth"] = h;
      };
      /**
       * @param {Object} o
       * @param {Object} params
       * @return {undefined}
       */
      var setFillAndStroke = function(o, params) {
        var par;
        var index;
        var div;
        var style;
        var textpathStyle;
        var fill;
        var newfill;
        var isURL;
        var bbox;
        var opacity;
        var stroke;
        var newstroke;
        var strokeColor;
        var width;
        var dasharray;
        var brect;
        var targetKeys;
        var i;
        var valsLength;
        o.attrs = o.attrs || {};
        var node = o.node;
        var a = o.attrs;
        var s = node.style;
        var ui = pathTypes[o.type] && (params.x != a.x || (params.y != a.y || (params.width != a.width || (params.height != a.height || (params.cx != a.cx || (params.cy != a.cy || (params.rx != a.rx || (params.ry != a.ry || params.r != a.r))))))));
        var ci = ovalTypes[o.type] && (a.cx != params.cx || (a.cy != params.cy || (a.r != params.r || (a.rx != params.rx || a.ry != params.ry))));
        /** @type {Object} */
        var res = o;
        for (par in params) {
          if (params[has](par)) {
            a[par] = params[par];
          }
        }
        if (ui && (a.path = R._getPath[o.type](o), o._.dirty = 1), params.href && (node.href = params.href), params.title && (node.title = params.title), params.target && (node.target = params.target), params.cursor && (s.cursor = params.cursor), "blur" in params && o.blur(params.blur), (params.path && o.type == "path" || ui) && (node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path), o.type == "image" && (o._.fillpos = [a.x, a.y], o._.fillsize = [a.width, 
        a.height], setCoords(o, 1, 1, 0, 0, 0))), "transform" in params && o.transform(params.transform), ci) {
          /** @type {number} */
          var cx = +a.cx;
          /** @type {number} */
          var cy = +a.cy;
          /** @type {number} */
          var rx = +a.rx || (+a.r || 0);
          /** @type {number} */
          var ry = +a.ry || (+a.r || 0);
          node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
          /** @type {number} */
          o._.dirty = 1;
        }
        if ("clip-rect" in params && (index = Str(params["clip-rect"]).split(separator), index.length == 4 && (index[2] = +index[2] + +index[0], index[3] = +index[3] + +index[1], div = node.clipRect || R._g.doc.createElement("div"), style = div.style, style.clip = R.format("rect({1}px {2}px {3}px {0}px)", index), node.clipRect || (style.position = "absolute", style.top = 0, style.left = 0, style.width = o.paper.width + "px", style.height = o.paper.height + "px", node.parentNode.insertBefore(div, 
        node), div.appendChild(node), node.clipRect = div)), params["clip-rect"] || node.clipRect && (node.clipRect.style.clip = "auto")), o.textpath && (textpathStyle = o.textpath.style, params.font && (textpathStyle.font = params.font), params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"'), params["font-size"] && (textpathStyle.fontSize = params["font-size"]), params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]), 
        params["font-style"] && (textpathStyle.fontStyle = params["font-style"])), "arrow-start" in params && addArrow(res, params["arrow-start"]), "arrow-end" in params && addArrow(res, params["arrow-end"], 1), (params.opacity != null || (params["stroke-width"] != null || (params.fill != null || (params.src != null || (params.stroke != null || (params["stroke-width"] != null || (params["stroke-opacity"] != null || (params["fill-opacity"] != null || (params["stroke-dasharray"] != null || (params["stroke-miterlimit"] != 
        null || (params["stroke-linejoin"] != null || params["stroke-linecap"] != null))))))))))) && (fill = node.getElementsByTagName(fillString), newfill = false, fill = fill && fill[0], fill || (newfill = fill = createNode(fillString)), o.type == "image" && (params.src && (fill.src = params.src)), params.fill && (fill.on = true), (fill.on == null || (params.fill == "none" || params.fill === null)) && (fill.on = false), fill.on && (params.fill && (isURL = Str(params.fill).match(R._ISURL), isURL ? 
        (fill.parentNode == node && node.removeChild(fill), fill.rotate = true, fill.src = isURL[1], fill.type = "tile", bbox = o.getBBox(1), fill.position = bbox.x + S + bbox.y, o._.fillpos = [bbox.x, bbox.y], R._preload(isURL[1], function() {
          /** @type {Array} */
          o._.fillsize = [this.offsetWidth, this.offsetHeight];
        })) : (fill.color = R.getRGB(params.fill).hex, fill.src = E, fill.type = "solid", R.getRGB(params.fill).error && ((res.type in {
          circle : 1,
          ellipse : 1
        } || Str(params.fill).charAt() != "r") && (addGradientFill(res, params.fill, fill) && (a.fill = "none", a.gradient = params.fill, fill.rotate = false)))))), ("fill-opacity" in params || "opacity" in params) && (opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1), opacity = mmin(mmax(opacity, 0), 1), fill.opacity = opacity, fill.src && (fill.color = "none")), node.appendChild(fill), stroke = node.getElementsByTagName("stroke") && 
        node.getElementsByTagName("stroke")[0], newstroke = false, stroke || (newstroke = stroke = createNode("stroke")), (params.stroke && params.stroke != "none" || (params["stroke-width"] || (params["stroke-opacity"] != null || (params["stroke-dasharray"] || (params["stroke-miterlimit"] || (params["stroke-linejoin"] || params["stroke-linecap"])))))) && (stroke.on = true), (params.stroke == "none" || (params.stroke === null || (stroke.on == null || (params.stroke == 0 || params["stroke-width"] == 
        0)))) && (stroke.on = false), strokeColor = R.getRGB(params.stroke), stroke.on && (params.stroke && (stroke.color = strokeColor.hex)), opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1), width = (toFloat(params["stroke-width"]) || 1) * 0.75, opacity = mmin(mmax(opacity, 0), 1), params["stroke-width"] == null && (width = a["stroke-width"]), params["stroke-width"] && (stroke.weight = width), width && (width < 1 && ((opacity *= width) && 
        (stroke.weight = 1))), stroke.opacity = opacity, params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter"), stroke.miterlimit = params["stroke-miterlimit"] || 8, params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round"), "stroke-dasharray" in params && (dasharray = {
          "-" : "shortdash",
          "." : "shortdot",
          "-." : "shortdashdot",
          "-.." : "shortdashdotdot",
          ". " : "dot",
          "- " : "dash",
          "--" : "longdash",
          "- ." : "dashdot",
          "--." : "longdashdot",
          "--.." : "longdashdotdot"
        }, stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E), newstroke && node.appendChild(stroke)), res.type == "text") {
          /** @type {string} */
          res.paper.canvas.style.display = E;
          var span = res.paper.span;
          /** @type {number} */
          var m = 100;
          var fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
          s = span.style;
          if (a.font) {
            s.font = a.font;
          }
          if (a["font-family"]) {
            s.fontFamily = a["font-family"];
          }
          if (a["font-weight"]) {
            s.fontWeight = a["font-weight"];
          }
          if (a["font-style"]) {
            s.fontStyle = a["font-style"];
          }
          /** @type {number} */
          fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
          /** @type {string} */
          s.fontSize = fontSize * m + "px";
          if (res.textpath.string) {
            /** @type {string} */
            span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>");
          }
          brect = span.getBoundingClientRect();
          /** @type {number} */
          res.W = a.w = (brect.right - brect.left) / m;
          /** @type {number} */
          res.H = a.h = (brect.bottom - brect.top) / m;
          res.X = a.x;
          res.Y = a.y + res.H / 2;
          if ("x" in params || "y" in params) {
            res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1);
          }
          /** @type {Array} */
          targetKeys = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
          /** @type {number} */
          i = 0;
          /** @type {number} */
          valsLength = targetKeys.length;
          for (;i < valsLength;i++) {
            if (targetKeys[i] in params) {
              /** @type {number} */
              res._.dirty = 1;
              break;
            }
          }
          switch(a["text-anchor"]) {
            case "start":
              /** @type {string} */
              res.textpath.style["v-text-align"] = "left";
              /** @type {number} */
              res.bbx = res.W / 2;
              break;
            case "end":
              /** @type {string} */
              res.textpath.style["v-text-align"] = "right";
              /** @type {number} */
              res.bbx = -res.W / 2;
              break;
            default:
              /** @type {string} */
              res.textpath.style["v-text-align"] = "center";
              /** @type {number} */
              res.bbx = 0;
          }
          /** @type {boolean} */
          res.textpath.style["v-text-kern"] = true;
        }
      };
      /**
       * @param {Object} o
       * @param {string} gradient
       * @param {Object} fill
       * @return {?}
       */
      var addGradientFill = function(o, gradient, fill) {
        var chr2;
        var dots;
        var leaks;
        var i;
        var valsLength;
        o.attrs = o.attrs || {};
        var attrs = o.attrs;
        /** @type {function (*, *): number} */
        var pow = Math.pow;
        /** @type {string} */
        var type = "linear";
        /** @type {string} */
        var fxfy = ".5 .5";
        if ((o.attrs.gradient = gradient, gradient = Str(gradient).replace(R._radial_gradient, function(dataAndEvents, fx, fy) {
          return type = "radial", fx && (fy && (fx = toFloat(fx), fy = toFloat(fy), pow(fx - 0.5, 2) + pow(fy - 0.5, 2) > 0.25 && (fy = math.sqrt(0.25 - pow(fx - 0.5, 2)) * ((fy > 0.5) * 2 - 1) + 0.5), fxfy = fx + S + fy)), E;
        }), gradient = gradient.split(/\s*\-\s*/), type == "linear" && (chr2 = gradient.shift(), chr2 = -toFloat(chr2), isNaN(chr2))) || (dots = R._parseDots(gradient), !dots)) {
          return null;
        }
        if (o = o.shape || o.node, dots.length) {
          o.removeChild(fill);
          /** @type {boolean} */
          fill.on = true;
          /** @type {string} */
          fill.method = "none";
          fill.color = dots[0].color;
          fill.color2 = dots[dots.length - 1].color;
          /** @type {Array} */
          leaks = [];
          /** @type {number} */
          i = 0;
          valsLength = dots.length;
          for (;i < valsLength;i++) {
            if (dots[i].offset) {
              leaks.push(dots[i].offset + S + dots[i].color);
            }
          }
          /** @type {string} */
          fill.colors = leaks.length ? leaks.join() : "0% " + fill.color;
          if (type == "radial") {
            /** @type {string} */
            fill.type = "gradientTitle";
            /** @type {string} */
            fill.focus = "100%";
            /** @type {string} */
            fill.focussize = "0 0";
            fill.focusposition = fxfy;
            /** @type {number} */
            fill.angle = 0;
          } else {
            /** @type {string} */
            fill.type = "gradient";
            /** @type {number} */
            fill.angle = (270 - chr2) % 360;
          }
          o.appendChild(fill);
        }
        return 1;
      };
      /**
       * @param {Object} node
       * @param {Object} vml
       * @return {undefined}
       */
      var Element = function(node, vml) {
        this[0] = this.node = node;
        /** @type {boolean} */
        node.raphael = true;
        /** @type {number} */
        this.id = R._oid++;
        /** @type {number} */
        node.raphaelid = this.id;
        /** @type {number} */
        this.X = 0;
        /** @type {number} */
        this.Y = 0;
        this.attrs = {};
        /** @type {Object} */
        this.paper = vml;
        this.matrix = R.matrix();
        this._ = {
          transform : [],
          sx : 1,
          sy : 1,
          dx : 0,
          dy : 0,
          deg : 0,
          dirty : 1,
          dirtyT : 1
        };
        if (!vml.bottom) {
          vml.bottom = this;
        }
        this.prev = vml.top;
        if (vml.top) {
          vml.top.next = this;
        }
        vml.top = this;
        /** @type {null} */
        this.next = null;
      };
      var elproto = R.el;
      Element.prototype = elproto;
      /** @type {function (Object, Object): undefined} */
      elproto.constructor = Element;
      /**
       * @param {string} value
       * @return {?}
       */
      elproto.transform = function(value) {
        var vbs;
        var vbt;
        var oldt;
        if (value == null) {
          return this._.transform;
        }
        vbs = this.paper._viewBoxShift;
        /** @type {string} */
        vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E;
        if (vbs) {
          /** @type {string} */
          oldt = value = Str(value).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + value);
        var matrix = this.matrix.clone();
        var skew = this.skew;
        var o = this.node;
        var split;
        /** @type {number} */
        var isGrad = ~Str(this.attrs.fill).indexOf("-");
        /** @type {boolean} */
        var isPatt = !Str(this.attrs.fill).indexOf("url(");
        if (matrix.translate(1, 1), isPatt || (isGrad || this.type == "image")) {
          if (skew.matrix = "1 0 0 1", skew.offset = "0 0", split = matrix.split(), isGrad && split.noRotation || !split.isSimple) {
            o.style.filter = matrix.toFilter();
            var bb = this.getBBox();
            var bbt = this.getBBox(1);
            /** @type {number} */
            var dx = bb.x - bbt.x;
            /** @type {number} */
            var dy = bb.y - bbt.y;
            /** @type {string} */
            o.coordorigin = dx * -zoom + S + dy * -zoom;
            setCoords(this, 1, 1, dx, dy, 0);
          } else {
            /** @type {string} */
            o.style.filter = E;
            setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
          }
        } else {
          /** @type {string} */
          o.style.filter = E;
          /** @type {string} */
          skew.matrix = Str(matrix);
          skew.offset = matrix.offset();
        }
        return oldt && (this._.transform = oldt), this;
      };
      /**
       * @param {number} deg
       * @param {number} cx
       * @param {number} cy
       * @return {?}
       */
      elproto.rotate = function(deg, cx, cy) {
        if (this.removed) {
          return this;
        }
        if (deg != null) {
          if (deg = Str(deg).split(separator), deg.length - 1 && (cx = toFloat(deg[1]), cy = toFloat(deg[2])), deg = toFloat(deg[0]), cy == null && (cx = cy), cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
          }
          return this._.dirtyT = 1, this.transform(this._.transform.concat([["r", deg, cx, cy]])), this;
        }
      };
      /**
       * @param {number} dx
       * @param {(number|string)} dy
       * @return {?}
       */
      elproto.translate = function(dx, dy) {
        return this.removed ? this : (dx = Str(dx).split(separator), dx.length - 1 && (dy = toFloat(dx[1])), dx = toFloat(dx[0]) || 0, dy = +dy || 0, this._.bbox && (this._.bbox.x += dx, this._.bbox.y += dy), this.transform(this._.transform.concat([["t", dx, dy]])), this);
      };
      /**
       * @param {(number|string)} sx
       * @param {(number|string)} sy
       * @param {string} cx
       * @param {string} cy
       * @return {?}
       */
      elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) {
          return this;
        }
        if (sx = Str(sx).split(separator), sx.length - 1 && (sy = toFloat(sx[1]), cx = toFloat(sx[2]), cy = toFloat(sx[3]), isNaN(cx) && (cx = null), isNaN(cy) && (cy = null)), sx = toFloat(sx[0]), sy == null && (sy = sx), cy == null && (cx = cy), cx == null || cy == null) {
          var bbox = this.getBBox(1)
        }
        return cx = cx == null ? bbox.x + bbox.width / 2 : cx, cy = cy == null ? bbox.y + bbox.height / 2 : cy, this.transform(this._.transform.concat([["s", sx, sy, cx, cy]])), this._.dirtyT = 1, this;
      };
      /**
       * @return {?}
       */
      elproto.hide = function() {
        return this.removed || (this.node.style.display = "none"), this;
      };
      /**
       * @return {?}
       */
      elproto.show = function() {
        return this.removed || (this.node.style.display = E), this;
      };
      /**
       * @return {?}
       */
      elproto._getBBox = function() {
        return this.removed ? {} : {
          x : this.X + (this.bbx || 0) - this.W / 2,
          y : this.Y - this.H,
          width : this.W,
          height : this.H
        };
      };
      /**
       * @return {undefined}
       */
      elproto.remove = function() {
        if (!this.removed && this.node.parentNode) {
          if (this.paper.__set__) {
            this.paper.__set__.exclude(this);
          }
          R.eve.unbind("raphael.*.*." + this.id);
          R._tear(this, this.paper);
          this.node.parentNode.removeChild(this.node);
          if (this.shape) {
            this.shape.parentNode.removeChild(this.shape);
          }
          var i;
          for (i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
          }
          /** @type {boolean} */
          this.removed = true;
        }
      };
      /**
       * @param {string} name
       * @param {?} value
       * @return {?}
       */
      elproto.attr = function(name, value) {
        var res;
        var a;
        var names;
        var out;
        var i;
        var ii;
        var params;
        var key;
        var par;
        var subkey;
        if (this.removed) {
          return this;
        }
        if (name == null) {
          res = {};
          for (a in this.attrs) {
            if (this.attrs[has](a)) {
              res[a] = this.attrs[a];
            }
          }
          return res.gradient && (res.fill == "none" && ((res.fill = res.gradient) && delete res.gradient)), res.transform = this._.transform, res;
        }
        if (value == null && R.is(name, "string")) {
          if (name == fillString && (this.attrs.fill == "none" && this.attrs.gradient)) {
            return this.attrs.gradient;
          }
          names = name.split(separator);
          out = {};
          /** @type {number} */
          i = 0;
          ii = names.length;
          for (;i < ii;i++) {
            name = names[i];
            out[name] = name in this.attrs ? this.attrs[name] : R.is(this.paper.customAttributes[name], "function") ? this.paper.customAttributes[name].def : R._availableAttrs[name];
          }
          return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && (value == null && R.is(name, "array"))) {
          out = {};
          /** @type {number} */
          i = 0;
          ii = name.length;
          for (;i < ii;i++) {
            out[name[i]] = this.attr(name[i]);
          }
          return out;
        }
        if (value != null) {
          params = {};
          params[name] = value;
        }
        if (value == null) {
          if (R.is(name, "object")) {
            /** @type {string} */
            params = name;
          }
        }
        for (key in params) {
          eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
          for (key in this.paper.customAttributes) {
            if (this.paper.customAttributes[has](key) && (params[has](key) && R.is(this.paper.customAttributes[key], "function"))) {
              par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
              this.attrs[key] = params[key];
              for (subkey in par) {
                if (par[has](subkey)) {
                  params[subkey] = par[subkey];
                }
              }
            }
          }
          if (params.text) {
            if (this.type == "text") {
              this.textpath.string = params.text;
            }
          }
          setFillAndStroke(this, params);
        }
        return this;
      };
      /**
       * @return {?}
       */
      elproto.toFront = function() {
        return this.removed || this.node.parentNode.appendChild(this.node), this.paper && (this.paper.top != this && R._tofront(this, this.paper)), this;
      };
      /**
       * @return {?}
       */
      elproto.toBack = function() {
        return this.removed ? this : (this.node.parentNode.firstChild != this.node && (this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild), R._toback(this, this.paper)), this);
      };
      /**
       * @param {Array} element
       * @return {?}
       */
      elproto.insertAfter = function(element) {
        return this.removed ? this : (element.constructor == R.st.constructor && (element = element[element.length - 1]), element.node.nextSibling ? element.node.parentNode.insertBefore(this.node, element.node.nextSibling) : element.node.parentNode.appendChild(this.node), R._insertafter(this, element, this.paper), this);
      };
      /**
       * @param {Object} element
       * @return {?}
       */
      elproto.insertBefore = function(element) {
        return this.removed ? this : (element.constructor == R.st.constructor && (element = element[0]), element.node.parentNode.insertBefore(this.node, element.node), R._insertbefore(this, element, this.paper), this);
      };
      /**
       * @param {string} value
       * @return {?}
       */
      elproto.blur = function(value) {
        var s = this.node.runtimeStyle;
        var f = s.filter;
        return f = f.replace(r20, E), +value != 0 ? (this.attrs.blur = value, s.filter = f + S + ms + ".Blur(pixelradius=" + (+value || 1.5) + ")", s.margin = R.format("-{0}px 0 0 -{0}px", round(+value || 1.5))) : (s.filter = f, s.margin = 0, delete this.attrs.blur), this;
      };
      /**
       * @param {number} value
       * @param {Function} o
       * @return {?}
       */
      R._engine.path = function(value, o) {
        var el = createNode("shape");
        var p;
        var attr;
        var skew;
        return el.style.cssText = stylesString, el.coordsize = zoom + S + zoom, el.coordorigin = o.coordorigin, p = new Element(el, o), attr = {
          fill : "none",
          stroke : "#000"
        }, value && (attr.path = value), p.type = "path", p.path = [], p.Path = E, setFillAndStroke(p, attr), o.canvas.appendChild(el), skew = createNode("skew"), skew.on = true, el.appendChild(skew), p.skew = skew, p.transform(E), p;
      };
      /**
       * @param {(Object|string)} d
       * @param {number} x
       * @param {?} y
       * @param {number} w
       * @param {number} h
       * @param {number} r
       * @return {?}
       */
      R._engine.rect = function(d, x, y, w, h, r) {
        var value = R._rectPath(x, y, w, h, r);
        var res = d.path(value);
        var a = res.attrs;
        return res.X = a.x = x, res.Y = a.y = y, res.W = a.width = w, res.H = a.height = h, a.r = r, a.path = value, res.type = "rect", res;
      };
      /**
       * @param {Error} parent
       * @param {number} x
       * @param {number} y
       * @param {number} rx
       * @param {number} ry
       * @return {?}
       */
      R._engine.ellipse = function(parent, x, y, rx, ry) {
        var res = parent.path();
        var a = res.attrs;
        return res.X = x - rx, res.Y = y - ry, res.W = rx * 2, res.H = ry * 2, res.type = "ellipse", setFillAndStroke(res, {
          cx : x,
          cy : y,
          rx : rx,
          ry : ry
        }), res;
      };
      /**
       * @param {Error} parent
       * @param {number} x
       * @param {number} y
       * @param {number} r
       * @return {?}
       */
      R._engine.circle = function(parent, x, y, r) {
        var res = parent.path();
        var a = res.attrs;
        return res.X = x - r, res.Y = y - r, res.W = res.H = r * 2, res.type = "circle", setFillAndStroke(res, {
          cx : x,
          cy : y,
          r : r
        }), res;
      };
      /**
       * @param {Error} ref
       * @param {?} src
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       * @return {?}
       */
      R._engine.image = function(ref, src, x, y, w, h) {
        var value = R._rectPath(x, y, w, h);
        var res = ref.path(value).attr({
          stroke : "none"
        });
        var a = res.attrs;
        var node = res.node;
        var fill = node.getElementsByTagName(fillString)[0];
        return a.src = src, res.X = a.x = x, res.Y = a.y = y, res.W = a.width = w, res.H = a.height = h, a.path = value, res.type = "image", fill.parentNode == node && node.removeChild(fill), fill.rotate = true, fill.src = src, fill.type = "tile", res._.fillpos = [x, y], res._.fillsize = [w, h], node.appendChild(fill), setCoords(res, 1, 1, 0, 0, 0), res;
      };
      /**
       * @param {string} item
       * @param {Object} value
       * @param {number} y
       * @param {string} text
       * @return {?}
       */
      R._engine.text = function(item, value, y, text) {
        var el = createNode("shape");
        var path = createNode("path");
        var o = createNode("textpath");
        var p;
        var attr;
        var skew;
        return value = value || 0, y = y || 0, text = text || "", path.v = R.format("m{0},{1}l{2},{1}", round(value * zoom), round(y * zoom), round(value * zoom) + 1), path.textpathok = true, o.string = Str(text), o.on = true, el.style.cssText = stylesString, el.coordsize = zoom + S + zoom, el.coordorigin = "0 0", p = new Element(el, item), attr = {
          fill : "#000",
          stroke : "none",
          font : R._availableAttrs.font,
          text : text
        }, p.shape = el, p.path = path, p.textpath = o, p.type = "text", p.attrs.text = Str(text), p.attrs.x = value, p.attrs.y = y, p.attrs.w = 1, p.attrs.h = 1, setFillAndStroke(p, attr), el.appendChild(o), el.appendChild(path), item.canvas.appendChild(el), skew = createNode("skew"), skew.on = true, el.appendChild(skew), p.skew = skew, p.transform(E), p;
      };
      /**
       * @param {string} width
       * @param {string} height
       * @return {?}
       */
      R._engine.setSize = function(width, height) {
        var cs = this.canvas.style;
        return this.width = width, this.height = height, width == +width && (width += "px"), height == +height && (height += "px"), cs.width = width, cs.height = height, cs.clip = "rect(0 " + width + " " + height + " 0)", this._viewBox && R._engine.setViewBox.apply(this, this._viewBox), this;
      };
      /**
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       * @param {boolean} fit
       * @return {?}
       */
      R._engine.setViewBox = function(x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var width = this.width;
        var height = this.height;
        /** @type {number} */
        var fromScale = 1 / mmax(w / width, h / height);
        var H;
        var W;
        return fit && (H = height / h, W = width / w, w * H < width && (x -= (width - w * H) / 2 / H), h * W < height && (y -= (height - h * W) / 2 / W)), this._viewBox = [x, y, w, h, !!fit], this._viewBoxShift = {
          dx : -x,
          dy : -y,
          scale : fromScale
        }, this.forEach(function(m3) {
          m3.transform("...");
        }), this;
      };
      /**
       * @param {Window} win
       * @return {undefined}
       */
      R._engine.initWin = function(win) {
        var doc = win.document;
        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        try {
          if (!doc.namespaces.rvml) {
            doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
          }
          /**
           * @param {string} tagName
           * @return {?}
           */
          createNode = function(tagName) {
            return doc.createElement("<rvml:" + tagName + ' class="rvml">');
          };
        } catch (i) {
          /**
           * @param {string} tagName
           * @return {?}
           */
          createNode = function(tagName) {
            return doc.createElement("<" + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
          };
        }
      };
      R._engine.initWin(R._g.win);
      /**
       * @return {?}
       */
      R._engine.create = function() {
        var con = R._getContainer.apply(0, arguments);
        var container = con.container;
        var height = con.height;
        var width = con.width;
        var x = con.x;
        var y = con.y;
        if (!container) {
          throw new Error("VML container not found.");
        }
        var res = new R._Paper;
        var c = res.canvas = R._g.doc.createElement("div");
        var cs = c.style;
        return x = x || 0, y = y || 0, width = width || 512, height = height || 342, res.width = width, res.height = height, width == +width && (width += "px"), height == +height && (height += "px"), res.coordsize = zoom * 1E3 + S + zoom * 1E3, res.coordorigin = "0 0", res.span = R._g.doc.createElement("span"), res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;", c.appendChild(res.span), cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", 
        width, height), container == 1 ? (R._g.doc.body.appendChild(c), cs.left = x + "px", cs.top = y + "px", cs.position = "absolute") : container.firstChild ? container.insertBefore(c, container.firstChild) : container.appendChild(c), res.renderfix = function() {
        }, res;
      };
      /**
       * @return {undefined}
       */
      R.prototype.clear = function() {
        R.eve("raphael.clear", this);
        /** @type {string} */
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        /** @type {string} */
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        /** @type {null} */
        this.bottom = this.top = null;
      };
      /**
       * @return {?}
       */
      R.prototype.remove = function() {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        var i;
        for (i in this) {
          this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
      };
      setproto = R.st;
      for (method in elproto) {
        if (elproto[has](method)) {
          if (!setproto[has](method)) {
            setproto[method] = function(methodName) {
              return function() {
                /** @type {Arguments} */
                var args = arguments;
                return this.forEach(function(wrapped) {
                  wrapped[methodName].apply(wrapped, args);
                });
              };
            }(method);
          }
        }
      }
    }
  }(), oldRaphael.was ? win.win.Raphael = R : Raphael = R, R;
});
